# Story 4.4: Manual Client Selection Fallback

## Status

Ready for Review

## Story

**As a** user,
**I want** to manually select a client from a dropdown when auto-matching fails,
**so that** I can still create tickets even for unmatched emails.

## Acceptance Criteria

1. Client dropdown component displays all active clients (alphabetically sorted)
2. Dropdown appears when no match found (manual mode)
3. Dropdown editable even when match found (user can override auto-selection)
4. Client dropdown loads on sidebar initialization (cached for performance)
5. Empty state for client dropdown: "No clients available"
6. Dropdown uses accessible UI components (keyboard navigation, ARIA labels)
7. Loading states for dropdown while data fetches

**Note:** Contact dropdown removed from story - contacts are auto-matched by email (Story 4.1). New contacts are created automatically during ticket submission when domain match occurs (Story 4.2).

## Tasks / Subtasks

- [x] **Task 1: Create API Client Function for Loading Clients** (AC: 1, 4)
  - [ ] Add `fetchClients()` function to [outlook-addin/src/lib/api/clients.ts](../../../outlook-addin/src/lib/api/clients.ts) (new file)
  - [ ] Import client types from [outlook-addin/src/types.ts](../../../outlook-addin/src/types.ts)
  - [ ] Use Fetch API with `credentials: 'include'` for session cookies (consistent with Story 4.1 pattern)
  - [ ] Construct request: `GET /api/clients` (existing endpoint, no query params needed)
  - [ ] Set request headers: `Content-Type: application/json`
  - [ ] Parse response JSON and validate structure (API returns array of client objects)
  - [ ] Return typed response: `Promise<Client[]>` - return all active clients sorted alphabetically by name
  - [ ] Add error handling for network failures, non-200 responses, and invalid JSON (consistent with `matchContactByEmail`)
  - [ ] [Source: [api-design-and-integration.md#reused-existing-endpoints](../architecture/api-design-and-integration.md#reused-existing-endpoints), Story 4.1 API client pattern]

- [x] **Task 2: Define TypeScript Types for Client Data** (AC: 1)
  - [x] Add `Client` interface to [outlook-addin/src/types.ts](../../../outlook-addin/src/types.ts)
  - [x] Structure: `{ id: number, name: string, isActive: boolean }`
  - [x] Ensure types align with backend API response format from existing `GET /api/clients` endpoint
  - [x] Export types for use in components and hooks
  - [x] [Source: [api-design-and-integration.md#reused-existing-endpoints](../architecture/api-design-and-integration.md#reused-existing-endpoints), [coding-standards-and-integration-rules.md#typescript-standards](../architecture/coding-standards-and-integration-rules.md#typescript-standards)]

- [x] **Task 3: Create Custom Hook for Client Data Management** (AC: 1, 4, 7)
  - [ ] Create new file [outlook-addin/src/hooks/useClients.ts](../../../outlook-addin/src/hooks/useClients.ts)
  - [ ] Implement `useClients()` hook with state management for clients list
  - [ ] Return object: `{ clients: Client[], isLoading: boolean, error: Error | null }`
  - [ ] Load clients on component mount using `useEffect` with empty dependency array (load once)
  - [ ] Sort clients alphabetically by `name` field before storing in state
  - [ ] Filter out inactive clients (`isActive === true`) before storing in state
  - [ ] Handle loading state: `isLoading: true` during fetch, `isLoading: false` after completion
  - [ ] Handle error state: catch errors, log to console, set error state for UI display
  - [ ] Cache results in component state (no refetching unless component unmounts and remounts)
  - [ ] [Source: Story 4.1 `useMatching` hook pattern, Epic 4.4 AC 1, 4, 7]

- [x] **Task 4: Create ClientDropdown Component** (AC: 1, 2, 3, 5, 6, 7)
  - [ ] Create new file [outlook-addin/src/components/ClientDropdown.tsx](../../../outlook-addin/src/components/ClientDropdown.tsx)
  - [ ] Implement React functional component with props: `{ value: number | null, onChange: (clientId: number | null) => void, disabled?: boolean }`
  - [ ] Use shadcn/ui Select component for dropdown (consistent with existing form components)
  - [ ] Display client names in dropdown options, sorted alphabetically (data pre-sorted by `useClients` hook)
  - [ ] Include "Select client..." placeholder option when no client selected
  - [ ] Display "No clients available" empty state when clients array is empty (AC 5)
  - [ ] Display loading spinner when `isLoading === true` from `useClients` hook (AC 7)
  - [ ] Display error message when `error !== null` from `useClients` hook: `<div role="alert">Failed to load clients. Please try again.</div>`
  - [ ] Set ARIA labels for accessibility: `aria-label="Client selection"` on SelectTrigger (AC 6)
  - [ ] Add `aria-required="true"` to SelectTrigger if client selection is mandatory for ticket submission
  - [ ] Ensure keyboard navigation works (Tab to focus, Arrow keys to select, Enter to confirm) (AC 6)
  - [ ] [Source: [component-architecture.md](../architecture/component-architecture.md), Epic 4.4 AC]

- [x] **Task 5: Integrate Client Dropdown into TicketForm Component** (AC: 2, 3)
  - [ ] Update [outlook-addin/src/components/TicketForm.tsx](../../../outlook-addin/src/components/TicketForm.tsx) to include ClientDropdown component
  - [ ] Import ClientDropdown component (state managed in App.tsx, passed as props)
  - [ ] Update component props to receive `selectedClient: { id: number, name: string } | null` and `onClientChange: (client: { id: number, name: string } | null) => void` from App.tsx
  - [ ] Display ClientDropdown always visible (editable in all modes per AC 3)
  - [ ] Pass `value={selectedClient?.id || null}` and `onChange` handler to ClientDropdown
  - [ ] Update ticket submission payload to use `selectedClient?.id` for `clientId` field
  - [ ] Add form validation: Prevent ticket submission if `selectedClient === null` (display error: "Client selection required")
  - [ ] [Source: [component-architecture.md#ticketform](../architecture/component-architecture.md), Epic 4.4 AC 2, 3]

- [x] **Task 6: Update App.tsx State Management for Client Selection** (AC: 2, 3)
  - [ ] Update [outlook-addin/src/App.tsx](../../../outlook-addin/src/App.tsx) to manage client selection state
  - [ ] Add state: `const [selectedClient, setSelectedClient] = useState<{ id: number, name: string } | null>(null)`
  - [ ] Auto-populate `selectedClient` when `matchingResult` contains client (contact match or domain match)
  - [ ] Reset `selectedClient` to `null` when email changes (new email context)
  - [ ] Pass `selectedClient` and `setSelectedClient` to TicketForm component as props
  - [ ] Ensure client selection persists when user manually overrides auto-match (AC 3)
  - [ ] [Source: Story 4.1 App.tsx state management pattern, Epic 4.4 AC]

- [x] **Task 7: Write Unit Tests for Client API Function** (AC: 1)
  - [ ] Create test file [outlook-addin/src/lib/api/__tests__/clients.test.ts](../../../outlook-addin/src/lib/api/__tests__/clients.test.ts)
  - [ ] Use Node test runner (consistent with Story 4.1 tests)
  - [ ] Mock `fetch` using same mocking strategy as `matchContactByEmail` tests
  - [ ] **Test Case 1:** Clients loaded successfully - verify function returns `Client[]` array
  - [ ] **Test Case 2:** Empty clients list - verify function returns empty array `[]`
  - [ ] **Test Case 3:** 401 Unauthorized - verify function throws error with correct message
  - [ ] **Test Case 4:** Network error - verify function handles fetch rejection gracefully
  - [ ] **Test Case 5:** Invalid JSON response - verify function handles parsing errors
  - [ ] Run tests: `npm test outlook-addin/src/lib/api/__tests__/clients.test.ts`
  - [ ] Ensure all tests pass before marking story complete
  - [ ] [Source: Story 4.1 testing pattern, [testing-strategy.md#new-testing-requirements](../architecture/testing-strategy.md#new-testing-requirements)]

- [ ] **Task 8: Manual Testing in Outlook Web** (AC: 1, 2, 3, 5, 6, 7)
  - [ ] **DEPENDENCY:** Backend `GET /api/clients` endpoint already exists (reusing existing endpoint)
  - [ ] Sideload add-in into Outlook Web and open task pane
  - [ ] **Test Case 1: Client Dropdown Loads on Initialization**
    - Open task pane
    - Verify loading spinner appears briefly (AC 7)
    - Verify client dropdown populates with alphabetically sorted clients (AC 1, 4)
    - Verify only active clients appear in dropdown
  - [ ] **Test Case 2: Client Dropdown Appears in Manual Mode (No Match)**
    - Select email with unknown contact and domain (no match)
    - Verify StatusBadge shows neutral status (gray ?)
    - Verify client dropdown is visible and enabled (AC 2)
    - Verify placeholder text "Select client..." appears when no selection
  - [ ] **Test Case 3: Client Auto-Populated from Contact Match**
    - Select email with existing contact (contact match found)
    - Verify StatusBadge shows matched status (green ✓)
    - Verify client dropdown is pre-filled with matched client name (AC 3)
    - Verify client dropdown is editable (user can change selection) (AC 3)
  - [ ] **Test Case 4: Client Auto-Populated from Domain Match**
    - Select email with unknown contact but known domain
    - Verify StatusBadge shows warning status (yellow/orange ⚠)
    - Verify client dropdown is pre-filled with matched client name (AC 3)
    - Verify client dropdown is editable (user can change selection) (AC 3)
  - [ ] **Test Case 5: Client Dropdown Empty State**
    - Manually clear clients data (or use test account with no clients)
    - Verify "No clients available" message appears (AC 5)
  - [ ] **Test Case 6: Keyboard Accessibility**
    - Tab to client dropdown (verify focus indicator appears)
    - Press Down Arrow key (verify dropdown opens and first option highlighted)
    - Press Enter key (verify selection made and dropdown closes)
    - Use screen reader (VoiceOver on macOS) to verify ARIA labels announced (AC 6)
  - [ ] **Test Case 7: Network Error Handling**
    - Use browser DevTools to simulate network failure (Offline mode)
    - Refresh add-in to trigger clients fetch
    - Verify error logged to console
    - Verify graceful error message displayed (not crash)
  - [ ] Document test results in completion notes
  - [ ] [Source: [testing-strategy.md#manual-testing-for-add-in-ui](../architecture/testing-strategy.md#manual-testing-for-add-in-ui), Epic 4.4 AC]

- [x] **Task 9: TypeScript Compilation and Linting** (AC: All)
  - [ ] Run TypeScript compilation: `npx tsc --noEmit` from outlook-addin directory
  - [ ] Verify no type errors in new/modified files (clients.ts, useClients.ts, ClientDropdown.tsx, types.ts, TicketForm.tsx, App.tsx)
  - [ ] Run linting: `npm run lint` from outlook-addin directory
  - [ ] Fix any ESLint errors or warnings in modified files
  - [ ] Verify imports use correct paths (relative for local files)
  - [ ] [Source: [coding-standards-and-integration-rules.md#typescript-standards](../architecture/coding-standards-and-integration-rules.md#typescript-standards)]

- [x] **Task 10: Update Documentation and Change Log** (AC: All)
  - [ ] Update Dev Notes section with implementation details (client dropdown integration, state management)
  - [ ] Document decision to remove contact dropdown (contacts auto-matched by email)
  - [ ] Add inline comments explaining client selection logic and auto-population
  - [ ] Update Change Log with story completion date and version
  - [ ] [Source: Story template standards]

## Dev Notes

### Previous Story Insights

**Story 4.1 (Email-to-Contact Matching Integration):**
- `useMatching` hook created in [outlook-addin/src/hooks/useMatching.ts](../../../outlook-addin/src/hooks/useMatching.ts)
- Hook implements 300ms debounce and AbortController for request cancellation
- API client function `matchContactByEmail` created in [outlook-addin/src/lib/api/matching.ts](../../../outlook-addin/src/lib/api/matching.ts)
- Authentication uses session-based auth with `credentials: 'include'`
- Error handling pattern established: catch errors, log to console, display error state, sidebar remains functional
- MatchingResult interface supports three types: `'contact-matched'`, `'domain-matched'`, `'no-match'`
- [Source: [4.1.email-to-contact-matching-integration.story.md](4.1.email-to-contact-matching-integration.story.md#dev-notes)]

**Story 4.2 (Domain-to-Client Fallback Matching):**
- Domain matching implemented as fallback when contact matching returns empty
- `matchingResult.type === 'domain-matched'` provides client without contact
- New contacts will be created automatically during ticket submission (backend handles this)
- Sequential matching logic: contact match first, then domain match if needed
- [Source: [4.2.domain-to-client-fallback-matching.story.md](4.2.domain-to-client-fallback-matching.story.md#dev-notes)]

**Story 4.3 (Matching Status Visual Feedback):**
- StatusBadge component supports four variants: `'loading'`, `'matched'`, `'warning'`, `'neutral'`
- Visual feedback displays matching status to user with color-coded badges
- Tooltips added for additional context
- WCAG AA color contrast requirements met for accessibility
- [Source: [4.3.matching-status-visual-feedback.story.md](4.3.matching-status-visual-feedback.story.md#dev-notes)]

**Story 4.4 Focus:** This story implements manual client selection as a fallback when auto-matching fails or when the user wants to override the auto-matched client. The key technical challenge is integrating the client dropdown with the existing matching state management while maintaining a seamless user experience.

**Critical Design Decision:** Contact dropdown removed from this story. Contacts are auto-matched by email (Story 4.1). When domain match occurs (Story 4.2), the contact does not exist yet and will be created automatically during ticket submission using the sender's email display name. This simplifies the UI and eliminates the need for manual contact selection.

### API Integration Architecture

**Existing Backend API Endpoint (Reused):**
- **Endpoint:** `GET /api/clients`
- **Authentication:** Session-based auth using HTTP-only cookies with `credentials: 'include'` (same as Story 4.1)
- **Request Headers:** `Content-Type: application/json`
- **Response Format:**
```json
[
  {
    "id": 5,
    "company_name": "Acme Corp",
    "is_active": true
  },
  {
    "id": 12,
    "company_name": "Beta Industries",
    "is_active": true
  }
]
```
- **Response (No Clients):** `[]` (empty array)
- **Error Responses:** `401 Unauthorized`, `500 Internal Server Error`
- **Note:** Backend endpoint returns `company_name` field (not `name`), so frontend must map to `name` property for consistency with other components
- [Source: [api-design-and-integration.md#reused-existing-endpoints](../architecture/api-design-and-integration.md#reused-existing-endpoints)]

**API Client Function Design:**
```typescript
// File: outlook-addin/src/lib/api/clients.ts
export async function fetchClients(): Promise<Client[]> {
  try {
    const apiUrl = import.meta.env.VITE_API_URL || '';
    const response = await fetch(
      `${apiUrl}/api/clients`,
      {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include', // Send session cookies
      }
    );

    if (!response.ok) {
      if (response.status === 401) {
        throw new Error('Authentication required. Please log in.');
      }
      throw new Error(`Server error: ${response.status}`);
    }

    const data = await response.json();

    // Map backend field names to frontend types
    // Backend returns: company_name, is_active
    // Frontend expects: name, isActive
    return data
      .filter((client: any) => client.is_active) // Filter active clients only
      .map((client: any) => ({
        id: client.id,
        name: client.company_name,
        isActive: client.is_active,
      }))
      .sort((a: Client, b: Client) => a.name.localeCompare(b.name)); // Sort alphabetically
  } catch (error) {
    console.error('Fetch clients API failed:', error);
    throw error;
  }
}
```
- [Source: Story 4.1 API client pattern, [coding-standards-and-integration-rules.md#api-integration](../architecture/coding-standards-and-integration-rules.md#api-integration)]

### Client Dropdown Component Design

**Component Responsibility:**
- Display dropdown of active clients, sorted alphabetically
- Support controlled component pattern (value + onChange props)
- Handle loading, empty, and error states
- Ensure keyboard accessibility (WCAG 2.1 Level AA)

**Component Implementation Strategy:**
```typescript
// File: outlook-addin/src/components/ClientDropdown.tsx
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { useClients } from '@/hooks/useClients';

interface ClientDropdownProps {
  value: number | null;
  onChange: (clientId: number | null) => void;
  disabled?: boolean;
}

export function ClientDropdown({ value, onChange, disabled = false }: ClientDropdownProps) {
  const { clients, isLoading, error } = useClients();

  if (isLoading) {
    return <div aria-label="Loading clients">Loading clients...</div>;
  }

  if (error) {
    return <div role="alert">Failed to load clients. Please try again.</div>;
  }

  if (clients.length === 0) {
    return <div>No clients available</div>;
  }

  return (
    <Select
      value={value?.toString() || ''}
      onValueChange={(val) => onChange(val ? parseInt(val, 10) : null)}
      disabled={disabled}
    >
      <SelectTrigger aria-label="Client selection">
        <SelectValue placeholder="Select client..." />
      </SelectTrigger>
      <SelectContent>
        {clients.map((client) => (
          <SelectItem key={client.id} value={client.id.toString()}>
            {client.name}
          </SelectItem>
        ))}
      </SelectContent>
    </Select>
  );
}
```
- **Note:** shadcn/ui Select component provides keyboard navigation and ARIA attributes by default
- **Note:** Value converted to string for Select component (shadcn/ui requirement), then parsed back to number in onChange
- [Source: [component-architecture.md](../architecture/component-architecture.md), shadcn/ui documentation]

### Client Selection State Management

**State Management Strategy:**
- Client selection state managed in App.tsx (top-level component)
- Auto-populate client from matching result (contact match or domain match)
- Allow user to override auto-populated client (manual selection)
- Reset client selection when email context changes (new email selected)

**App.tsx Integration:**
```typescript
// File: outlook-addin/src/App.tsx (excerpt)
const [selectedClient, setSelectedClient] = useState<{ id: number, name: string } | null>(null);

// Auto-populate client from matching result
useEffect(() => {
  if (matchingResult?.client) {
    setSelectedClient(matchingResult.client);
  } else {
    setSelectedClient(null);
  }
}, [matchingResult]);

// Reset client selection when email changes
useEffect(() => {
  if (emailContext?.senderEmail) {
    setSelectedClient(null);
  }
}, [emailContext?.senderEmail]);

// Pass to TicketForm
<TicketForm
  selectedClient={selectedClient}
  onClientChange={setSelectedClient}
  matchingResult={matchingResult}
/>
```
- [Source: Story 4.1 App.tsx state management pattern]

### TypeScript Type Definitions

**Client Interface (New):**
```typescript
// File: outlook-addin/src/types.ts (new addition for Story 4.4)
export interface Client {
  id: number;
  name: string;
  isActive: boolean;
}
```
- **Note:** `name` field maps to backend's `company_name` field (handled in API client function)
- [Source: [api-design-and-integration.md#reused-existing-endpoints](../architecture/api-design-and-integration.md#reused-existing-endpoints)]

**TicketForm Props Update:**
```typescript
// File: outlook-addin/src/components/TicketForm.tsx
interface TicketFormProps {
  selectedClient: { id: number, name: string } | null;
  onClientChange: (client: { id: number, name: string } | null) => void;
  matchingResult: MatchingResult | null;
  // ... other props
}
```

### File Locations

**New Files:**
- [outlook-addin/src/lib/api/clients.ts](../../../outlook-addin/src/lib/api/clients.ts) - Client API client function
- [outlook-addin/src/lib/api/__tests__/clients.test.ts](../../../outlook-addin/src/lib/api/__tests__/clients.test.ts) - Unit tests for client API
- [outlook-addin/src/hooks/useClients.ts](../../../outlook-addin/src/hooks/useClients.ts) - Custom hook for client data management
- [outlook-addin/src/components/ClientDropdown.tsx](../../../outlook-addin/src/components/ClientDropdown.tsx) - Client dropdown component

**Modified Files:**
- [outlook-addin/src/types.ts](../../../outlook-addin/src/types.ts) - Add `Client` interface
- [outlook-addin/src/components/TicketForm.tsx](../../../outlook-addin/src/components/TicketForm.tsx) - Integrate ClientDropdown component
- [outlook-addin/src/App.tsx](../../../outlook-addin/src/App.tsx) - Add client selection state management

[Source: [source-tree-organization.md#new-file-organization](../architecture/source-tree-organization.md#new-file-organization)]

### Integration with Existing State Management

**Current State Management (After Stories 4.1, 4.2, 4.3):**
- App.tsx uses `useMatching` hook: `const { matchingResult, isMatching, error } = useMatching(emailContext)`
- `matchingResult` state updated by `useMatching` hook based on matching results
- StatusBadge displays visual feedback based on `matchingResult.type`
- EmailContext component receives `matchingResult` and displays client/contact names
- [Source: Story 4.1, 4.2, 4.3 Dev Notes]

**State Management After Story 4.4:**
- App.tsx adds client selection state: `const [selectedClient, setSelectedClient] = useState<{ id: number, name: string } | null>(null)`
- Client auto-populated from `matchingResult.client` when match found
- User can override auto-populated client via ClientDropdown
- TicketForm uses `selectedClient` for ticket submission payload
- Client selection persists until email context changes (new email selected)

### Success Criteria

**Story Completion Checklist:**
1. Client API function `fetchClients` created and tested (AC 1)
2. `Client` interface added to types.ts (AC 1)
3. `useClients` hook created with loading/error states (AC 4, 7)
4. ClientDropdown component created with accessibility features (AC 1, 5, 6)
5. ClientDropdown integrated into TicketForm (AC 2, 3)
6. Client selection state managed in App.tsx (AC 3)
7. Unit tests for client API function pass (AC 1)
8. Manual testing confirms all acceptance criteria met
9. TypeScript compilation passes
10. Linting passes for all modified files

**Definition of Done:**
- [outlook-addin/src/lib/api/clients.ts](../../../outlook-addin/src/lib/api/clients.ts) implements client fetching with error handling
- [outlook-addin/src/hooks/useClients.ts](../../../outlook-addin/src/hooks/useClients.ts) manages client data with loading/error states
- [outlook-addin/src/components/ClientDropdown.tsx](../../../outlook-addin/src/components/ClientDropdown.tsx) renders accessible dropdown
- [outlook-addin/src/components/TicketForm.tsx](../../../outlook-addin/src/components/TicketForm.tsx) integrates ClientDropdown
- [outlook-addin/src/App.tsx](../../../outlook-addin/src/App.tsx) manages client selection state
- Unit tests pass: `npm test outlook-addin/src/lib/api/__tests__/clients.test.ts`
- TypeScript compilation passes: `npx tsc --noEmit`
- Linting passes: `npm run lint`
- Manual testing in Outlook Web confirms all 7 test cases pass
- Client dropdown displays alphabetically sorted active clients
- Client auto-populated from matching results (contact or domain match)
- User can override auto-populated client

[Source: Epic 4.4 AC + Story Template standards]

### Testing

#### Testing Standards

**Test Framework:** Node test runner (consistent with Story 4.1, 4.2 tests)

**Test File Locations:**
- [outlook-addin/src/lib/api/__tests__/clients.test.ts](../../../outlook-addin/src/lib/api/__tests__/clients.test.ts) - Client API client tests

**Testing Patterns:**
- Mock `fetch` API using same strategy as Story 4.1, 4.2 tests
- Test success cases (clients loaded, empty list)
- Test error cases (401, 500, network error)
- Test data transformation (backend field mapping to frontend types)
- Test sorting (alphabetical order by name)

[Source: [testing-strategy.md#new-testing-requirements](../architecture/testing-strategy.md#new-testing-requirements), Story 4.1, 4.2 testing pattern]

#### Unit Test Cases for Client API Function

**Test Suite:** `fetchClients()`

**Test Case 1: Clients Loaded Successfully**
- Mock fetch response: `200 OK` with JSON array containing multiple client objects
- Assert function returns `Client[]` array
- Assert clients sorted alphabetically by `name` field
- Assert only active clients included (`isActive === true`)
- Assert backend field names mapped correctly (`company_name` → `name`, `is_active` → `isActive`)

**Test Case 2: Empty Clients List**
- Mock fetch response: `200 OK` with empty JSON array `[]`
- Assert function returns empty array `[]`

**Test Case 3: 401 Unauthorized**
- Mock fetch response: `401 Unauthorized`
- Assert function throws error with message "Authentication required. Please log in."

**Test Case 4: 500 Internal Server Error**
- Mock fetch response: `500 Internal Server Error`
- Assert function throws error with message "Server error: 500"

**Test Case 5: Network Error**
- Mock fetch to reject promise (simulate network failure)
- Assert function throws error (error message may vary based on fetch implementation)

**Test Case 6: Invalid JSON Response**
- Mock fetch response: `200 OK` with invalid JSON body (e.g., HTML error page)
- Assert function throws error or handles parsing failure gracefully

**Expected Results:**
- All tests pass when run via `npm test outlook-addin/src/lib/api/__tests__/clients.test.ts`
- Test coverage >80% for `fetchClients` function

[Source: Story 4.1, 4.2 testing pattern, [testing-strategy.md#new-testing-requirements](../architecture/testing-strategy.md#new-testing-requirements)]

#### Manual Testing in Outlook Web

**Test Environment:** Outlook Web (Chrome, Safari on macOS)

**Prerequisites:**
- Backend `GET /api/clients` endpoint available (existing endpoint)
- Add-in sideloaded into Outlook Web with valid manifest
- User authenticated to backend API (session cookie set)
- Test data: Multiple active clients in database

**Manual Test Scenarios:**

**Test Case 1: Client Dropdown Loads on Initialization**
1. Open Outlook Web and sideload add-in
2. Open task pane
3. Observe loading state: Verify "Loading clients..." message appears briefly
4. Verify client dropdown populates with alphabetically sorted clients
5. Verify only active clients appear in dropdown (`is_active = true` in database)

**Test Case 2: Client Dropdown Appears in Manual Mode (No Match)**
1. Select email with unknown contact and domain (no match)
2. Verify StatusBadge shows neutral status (gray ? icon)
3. Verify client dropdown is visible and enabled
4. Verify placeholder text "Select client..." appears when no selection made
5. Verify dropdown can be opened and client selected

**Test Case 3: Client Auto-Populated from Contact Match and Override Persistence**
1. Select email with existing contact (contact match found)
2. Verify StatusBadge shows matched status (green ✓ icon)
3. Verify client dropdown is pre-filled with matched client name (AC 3)
4. Verify client dropdown is still editable (user can click and change selection) (AC 3)
5. Manually change client selection to different client, verify new selection displayed
6. Verify override selection persists when switching focus to other form fields and back
7. Fill out ticket form (description, time entry) and submit
8. Verify ticket submission payload uses manually overridden client ID (not original auto-matched client)
9. Verify ticket created successfully with overridden client
10. Switch to different email and back to same email, verify client dropdown resets to auto-matched client (not persisted override)

**Test Case 4: Client Auto-Populated from Domain Match**
1. Select email with unknown contact but known domain (domain match found)
2. Verify StatusBadge shows warning status (yellow/orange ⚠ icon)
3. Verify client dropdown is pre-filled with matched client name (from domain match)
4. Verify client dropdown is still editable (user can click and change selection)

**Test Case 5: Client Dropdown Empty State**
1. Use test account with no active clients in database
2. Verify "No clients available" message appears in dropdown area
3. Verify no dropdown component rendered (only empty state message)

**Test Case 6: Keyboard Accessibility**
1. Tab to client dropdown (verify focus indicator appears - blue outline or similar)
2. Press Down Arrow key (verify dropdown opens and first option highlighted)
3. Press Up/Down Arrow keys to navigate options (verify highlight moves)
4. Press Enter key (verify selection made and dropdown closes)
5. Press Escape key while dropdown open (verify dropdown closes without selection)
6. Use screen reader (VoiceOver on macOS):
   - Tab to dropdown, verify announced as "Client selection, combo box"
   - Open dropdown, verify options announced with client names

**Test Case 7: Network Error Handling**
1. Use browser DevTools Network tab to simulate network failure (Offline mode)
2. Refresh add-in to trigger clients fetch
3. Verify error logged to console: "Fetch clients API failed: [error]"
4. Verify graceful error message displayed: "Failed to load clients. Please try again."
5. Verify add-in does not crash (sidebar remains visible)

**Expected Results:**
- All 7 test cases pass without errors
- Client dropdown loads and displays active clients alphabetically
- Client auto-populated from matching results (contact or domain match)
- User can override auto-populated client
- Keyboard navigation works correctly
- Error handling prevents crash

[Source: [testing-strategy.md#manual-testing-for-add-in-ui](../architecture/testing-strategy.md#manual-testing-for-add-in-ui), Epic 4.4 AC]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-10 | 1.0 | Initial story creation - Manual client selection fallback with dropdown (contact dropdown removed based on user feedback) | Bob (Scrum Master) |
| 2025-10-10 | 1.1 | Story validation and fixes: Updated Epic 4.4 AC to remove contact dropdown; Fixed state management conflicts (Task 5/6); Added error state UI to Task 4; Added form validation to Task 5; Enhanced Test Case 3 for override persistence testing; Added types.ts to TypeScript compilation task. Story approved for implementation. | Sarah (Product Owner) |
| 2025-10-10 | 1.2 | Implementation complete - Created Client API function, useClients hook, ClientDropdown component. Updated TicketForm and App.tsx for client selection state management. All unit tests pass (8/8). TypeScript compilation and linting pass. Status: Ready for Review (pending manual testing in Outlook Web). | James (Dev Agent) |

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References

None

### Completion Notes List

- **Task 1-2**: Created `Client` interface in types.ts with `isActive` field. Created `fetchClients()` API client function with proper error handling, field mapping (company_name → name), active client filtering, and alphabetical sorting.
- **Task 3**: Created `useClients` hook that loads clients once on mount and caches results in state with loading and error states.
- **Task 4**: Created `ClientDropdown` component using shadcn/ui Select component with accessibility features (ARIA labels, keyboard navigation). Component handles loading, empty, and error states.
- **Task 5**: Updated `TicketForm` component to integrate `ClientDropdown`. Replaced old client dropdown with new component. Added form validation to prevent submission without client selection. Updated props interface to receive `selectedClient` and `onClientChange` from App.tsx.
- **Task 6**: Updated `App.tsx` to add client selection state management. Added `selectedClient` state and two useEffect hooks: one to auto-populate client from `matchingResult`, and one to reset selection when email changes.
- **Task 7**: Created comprehensive unit tests for `fetchClients()` API function covering 8 test cases: successful fetch, empty list, 401/500 errors, network failure, invalid JSON, field mapping, and filtering inactive clients. All tests pass.
- **Task 9**: TypeScript compilation passes with no errors. Linting passes for all modified files (fixed `any` types and unused imports).
- **Task 8**: Manual testing in Outlook Web pending - requires user to sideload add-in and test in Outlook environment.

**Implementation Notes:**
- Contact dropdown removed as per story requirements - contacts are auto-matched by email (Story 4.1) or created automatically during ticket submission (Story 4.2)
- Client dropdown is always visible and editable, even when client is auto-populated from matching results
- Backend API endpoint `GET /api/clients` is reused (no backend changes required)
- Field mapping implemented to convert backend snake_case (`company_name`, `is_active`) to frontend camelCase (`name`, `isActive`)

### File List

**New Files:**
- `outlook-addin/src/lib/api/clients.ts` - Client API client function
- `outlook-addin/src/lib/api/__tests__/clients.test.ts` - Unit tests for client API
- `outlook-addin/src/hooks/useClients.ts` - Custom hook for client data management
- `outlook-addin/src/components/ClientDropdown.tsx` - Client dropdown component

**Modified Files:**
- `outlook-addin/src/types.ts` - Added `isActive` field to `Client` interface
- `outlook-addin/src/components/TicketForm.tsx` - Integrated ClientDropdown component, updated props interface
- `outlook-addin/src/App.tsx` - Added client selection state management with auto-population from matching results

## QA Results

(To be populated by QA Agent)