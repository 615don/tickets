# Story 5.4: Ticket Submission to Backend API

## Status

Ready for Review

## Story

**As a** developer,
**I want** to submit the completed form to the existing ticket creation API,
**so that** tickets are created from the add-in.

## Acceptance Criteria

1. API client function: `createTicket(ticketData)` calls `POST /api/tickets`
2. Request payload includes: client_id, contact_id (or new contact data), time entry (work_date, duration_hours), description, notes, state (open or closed)
3. Authentication included in request (session cookie or token)
4. Form submission triggers API call on button click
5. Loading state displayed during submission (button disabled, spinner)
6. Success handling: display confirmation message, clear form, reset to next email
7. Error handling: display clear error messages (validation errors, API failures, network errors)
8. New contact creation handled: if new contact, include contact creation in request or call separate endpoint first
9. Unit tests for API client function (mocked fetch)

## Tasks / Subtasks

- [x] **Task 1: Create API Client Utility with Authentication** (AC: 1, 3)
  - [ ] Create new file: [outlook-addin/src/lib/api-client.ts](../../../outlook-addin/src/lib/api-client.ts)
  - [ ] **API Client Base Configuration:**
    ```typescript
    const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:3001';

    export async function apiClient<T>(
      endpoint: string,
      options: RequestInit = {}
    ): Promise<T> {
      const url = `${API_BASE_URL}${endpoint}`;

      const config: RequestInit = {
        ...options,
        headers: {
          'Content-Type': 'application/json',
          ...options.headers,
        },
        credentials: 'include', // Include session cookies for auth
      };

      try {
        const response = await fetch(url, config);

        if (!response.ok) {
          // Handle HTTP errors
          if (response.status === 401) {
            throw new Error('Authentication required. Please log in to the web app.');
          }

          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.message || `HTTP ${response.status}: ${response.statusText}`);
        }

        return await response.json();
      } catch (error) {
        // Network errors or fetch failures
        if (error instanceof TypeError) {
          throw new Error('Network error. Check your connection and try again.');
        }
        throw error;
      }
    }
    ```
  - [ ] Export `apiClient` function for reuse across API service modules
  - [ ] [Source: [api-design-and-integration.md#authentication](../architecture/api-design-and-integration.md#authentication), [coding-standards-and-integration-rules.md#api-integration](../architecture/coding-standards-and-integration-rules.md#api-integration)]

- [x] **Task 2: Create Ticket API Service Module** (AC: 1, 2, 8)
  - [ ] Create new file: [outlook-addin/src/lib/api/tickets.ts](../../../outlook-addin/src/lib/api/tickets.ts)
  - [ ] **Define TypeScript Interfaces for Ticket Submission:**
    ```typescript
    export interface TimeEntryData {
      workDate: string; // ISO date format YYYY-MM-DD
      durationHours: number; // Decimal hours
      billable: boolean;
    }

    export interface NewContactData {
      name: string;
      email: string;
    }

    export interface CreateTicketPayload {
      clientId: number;
      contactId: number; // 0 for new contact creation
      description: string;
      notes: string;
      state: 'open' | 'closed';
      timeEntry: TimeEntryData;
      newContact?: NewContactData; // Only included when contactId === 0
    }

    export interface CreateTicketResponse {
      id: number;
      clientId: number;
      contactId: number;
      description: string;
      state: string;
      createdAt: string;
    }
    ```
  - [ ] **Implement `createTicket` Function (AC 1, 2, 8):**
    ```typescript
    import { apiClient } from '../api-client';

    export async function createTicket(
      payload: CreateTicketPayload
    ): Promise<CreateTicketResponse> {
      return apiClient<CreateTicketResponse>('/api/tickets', {
        method: 'POST',
        body: JSON.stringify(payload),
      });
    }
    ```
  - [ ] Payload structure must match existing backend format (AC 2)
  - [ ] When `contactId === 0`, include `newContact` object for backend contact creation (AC 8)
  - [ ] When `contactId > 0`, omit `newContact` object (existing contact)
  - [ ] [Source: [api-design-and-integration.md#post-api-tickets](../architecture/api-design-and-integration.md#post-api-tickets), [coding-standards-and-integration-rules.md#critical-integration-rules](../architecture/coding-standards-and-integration-rules.md#critical-integration-rules)]

- [x] **Task 3: Update TicketForm Component for Submission Logic** (AC: 4, 5, 6, 7)
  - [ ] Read existing TicketForm component: [outlook-addin/src/components/TicketForm.tsx](../../../outlook-addin/src/components/TicketForm.tsx)
  - [ ] Import `createTicket` function and `CreateTicketPayload` type from `lib/api/tickets`
  - [ ] Add `Loader2` icon import from `lucide-react` (if not already present)
  - [ ] **Add Submission State Management:**
    ```typescript
    const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
    const [submitError, setSubmitError] = useState<string>("");
    ```
  - [ ] **Update `handleSubmit` Function (AC 4, 5, 6, 7):**
    ```typescript
    const handleSubmit = async (e: FormEvent) => {
      e.preventDefault();

      // Client-side validation (existing logic from Story 5.3)
      if (!selectedClient) {
        setValidationError("Client selection required");
        return;
      }

      // Contact validation for new contact scenarios
      if (matchingResult?.type === 'domain-matched' || matchingResult?.type === 'no-match') {
        if (contactName.trim().length === 0) {
          setContactNameError("Contact name is required");
          return;
        }
        // Email validation already in Story 5.3
      }

      // Time validation (from Story 5.2)
      if (!isTimeValid || parsedHours === null) {
        setTimeError("Invalid time format. Examples: 2h, 30m, 1.5h");
        return;
      }

      // Clear previous errors
      setValidationError("");
      setSubmitError("");

      // Set loading state (AC 5)
      setIsSubmitting(true);

      try {
        // Build payload
        const payload: CreateTicketPayload = {
          clientId: selectedClient.id,
          contactId: matchingResult?.type === 'contact-matched'
            ? matchingResult.contact.id
            : 0, // 0 signals new contact creation
          description: description.trim(),
          notes: notes.trim(),
          state: markAsClosed ? 'closed' : 'open',
          timeEntry: {
            workDate: new Date().toISOString().split('T')[0], // Today's date YYYY-MM-DD
            durationHours: parsedHours,
            billable: true,
          },
        };

        // Include new contact data if creating new contact (AC 8)
        if (payload.contactId === 0) {
          payload.newContact = {
            name: contactName.trim(),
            email: contactEmail.trim(),
          };
        }

        // Call API (AC 4)
        const response = await createTicket(payload);

        // Success handling (AC 6)
        onSubmit(response); // Pass response to parent (App.tsx) for success banner

      } catch (error) {
        // Error handling (AC 7)
        setIsSubmitting(false);

        if (error instanceof Error) {
          setSubmitError(error.message);
        } else {
          setSubmitError("An unexpected error occurred. Please try again.");
        }
      }
    };
    ```
  - [ ] **Update Submit Button UI (AC 5):**
    ```tsx
    <button
      type="submit"
      disabled={!isFormValid || isSubmitting}
      className={`w-full py-2 px-4 rounded-md font-medium transition-colors ${
        !isFormValid || isSubmitting
          ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
          : 'bg-blue-600 text-white hover:bg-blue-700'
      }`}
    >
      {isSubmitting ? (
        <span className="flex items-center justify-center">
          <Loader2 className="animate-spin mr-2" size={16} />
          Creating Ticket...
        </span>
      ) : (
        'Create Ticket'
      )}
    </button>
    ```
  - [ ] Display submit errors below submit button (AC 7):
    ```tsx
    {submitError && (
      <div className="text-red-600 text-sm mt-2">
        {submitError}
      </div>
    )}
    ```
  - [ ] [Source: [component-architecture.md#ticketform](../architecture/component-architecture.md#ticketform), Story 5.2 and 5.3 validation patterns]

- [x] **Task 4: Update App.tsx for Success Handling and Form Reset** (AC: 6)
  - [ ] Read existing App.tsx: [outlook-addin/src/App.tsx](../../../outlook-addin/src/App.tsx)
  - [ ] Import existing SuccessBanner component: `import { SuccessBanner } from './components/SuccessBanner';`
  - [ ] Import CreateTicketResponse type: `import { CreateTicketResponse } from './lib/api/tickets';`
  - [ ] **Add Success State Management:**
    ```typescript
    const [createdTicketId, setCreatedTicketId] = useState<number | null>(null);
    ```
  - [ ] **Update `handleTicketSubmit` Callback (AC 6):**
    ```typescript
    const handleTicketSubmit = (response: CreateTicketResponse) => {
      // Set ticket ID for success banner
      setCreatedTicketId(response.id);

      // Clear form state
      setDescription("");
      setNotes("");
      setMarkAsClosed(false);
      setContactName("");
      setContactEmail("");
      setSelectedClient(null);

      // Reset time input to default (2 minutes / 0.03h)
      // (handled by TicketForm internal state reset)

      // Note: "Reset to next email" (AC 6) deferred to Story 5.7 (Form Auto-Clear on Email Change)
      // For now, form clears but stays on same email
    };
    ```
  - [ ] **Add handleDismissSuccess callback:**
    ```typescript
    const handleDismissSuccess = () => {
      setCreatedTicketId(null);
    };
    ```
  - [ ] Pass `handleTicketSubmit` callback to TicketForm via `onSubmit` prop
  - [ ] Render SuccessBanner component when ticket is created (place at top of form, before EmailContext):
    ```tsx
    {createdTicketId && (
      <SuccessBanner
        ticketId={createdTicketId}
        showLink={false}
        onDismiss={handleDismissSuccess}
      />
    )}
    ```
  - [ ] [Source: Story 5.1 App.tsx state management patterns, [outlook-addin/src/components/SuccessBanner.tsx](../../../outlook-addin/src/components/SuccessBanner.tsx)]

- [x] **Task 5: Unit Tests for API Client Function** (AC: 9)
  - [ ] Create test file: [outlook-addin/src/lib/api/__tests__/tickets.test.ts](../../../outlook-addin/src/lib/api/__tests__/tickets.test.ts)
  - [ ] **Test Setup - Mock Fetch:**
    ```typescript
    import { describe, it, beforeEach, afterEach, mock } from 'node:test';
    import assert from 'node:assert';
    import { createTicket, CreateTicketPayload } from '../tickets';

    describe('createTicket API', () => {
      let originalFetch: typeof global.fetch;

      beforeEach(() => {
        originalFetch = global.fetch;
      });

      afterEach(() => {
        global.fetch = originalFetch;
      });
    });
    ```
  - [ ] **Test Case 1: Successful Ticket Creation (Existing Contact)**
    ```typescript
    it('should create ticket with existing contact', async () => {
      const mockResponse = {
        id: 123,
        clientId: 5,
        contactId: 42,
        description: "Email support",
        state: "closed",
        createdAt: "2025-10-11T12:00:00Z",
      };

      global.fetch = mock.fn(async () => ({
        ok: true,
        status: 200,
        json: async () => mockResponse,
      })) as any;

      const payload: CreateTicketPayload = {
        clientId: 5,
        contactId: 42,
        description: "Email support",
        notes: "Helped with email configuration",
        state: "closed",
        timeEntry: {
          workDate: "2025-10-11",
          durationHours: 0.5,
          billable: true,
        },
      };

      const result = await createTicket(payload);

      assert.strictEqual(result.id, 123);
      assert.strictEqual(result.contactId, 42);
      assert.strictEqual(global.fetch.mock.calls.length, 1);

      const [url, options] = global.fetch.mock.calls[0].arguments;
      assert.ok(url.includes('/api/tickets'));
      assert.strictEqual(options.method, 'POST');
      assert.strictEqual(options.credentials, 'include');
    });
    ```
  - [ ] **Test Case 2: Successful Ticket Creation (New Contact)**
    ```typescript
    it('should create ticket with new contact', async () => {
      const mockResponse = {
        id: 124,
        clientId: 5,
        contactId: 99, // Backend returns newly created contact ID
        description: "Email support",
        state: "open",
        createdAt: "2025-10-11T12:00:00Z",
      };

      global.fetch = mock.fn(async () => ({
        ok: true,
        status: 200,
        json: async () => mockResponse,
      })) as any;

      const payload: CreateTicketPayload = {
        clientId: 5,
        contactId: 0, // Signal new contact creation
        description: "Email support",
        notes: "New contact from email",
        state: "open",
        timeEntry: {
          workDate: "2025-10-11",
          durationHours: 0.5,
          billable: true,
        },
        newContact: {
          name: "Jane Doe",
          email: "jane.doe@acme.com",
        },
      };

      const result = await createTicket(payload);

      assert.strictEqual(result.id, 124);
      assert.strictEqual(result.contactId, 99); // New contact ID from backend

      const [url, options] = global.fetch.mock.calls[0].arguments;
      const requestBody = JSON.parse(options.body);
      assert.strictEqual(requestBody.contactId, 0);
      assert.strictEqual(requestBody.newContact.name, "Jane Doe");
    });
    ```
  - [ ] **Test Case 3: Authentication Error (401)**
    ```typescript
    it('should throw authentication error on 401', async () => {
      global.fetch = mock.fn(async () => ({
        ok: false,
        status: 401,
        statusText: 'Unauthorized',
        json: async () => ({ message: 'Session expired' }),
      })) as any;

      const payload: CreateTicketPayload = {
        clientId: 5,
        contactId: 42,
        description: "Test",
        notes: "",
        state: "open",
        timeEntry: {
          workDate: "2025-10-11",
          durationHours: 0.5,
          billable: true,
        },
      };

      await assert.rejects(
        async () => await createTicket(payload),
        {
          message: /Authentication required/,
        }
      );
    });
    ```
  - [ ] **Test Case 4: Network Error**
    ```typescript
    it('should throw network error on fetch failure', async () => {
      global.fetch = mock.fn(async () => {
        throw new TypeError('Failed to fetch');
      }) as any;

      const payload: CreateTicketPayload = {
        clientId: 5,
        contactId: 42,
        description: "Test",
        notes: "",
        state: "open",
        timeEntry: {
          workDate: "2025-10-11",
          durationHours: 0.5,
          billable: true,
        },
      };

      await assert.rejects(
        async () => await createTicket(payload),
        {
          message: /Network error/,
        }
      );
    });
    ```
  - [ ] **Test Case 5: API Validation Error (400)**
    ```typescript
    it('should throw validation error on 400', async () => {
      global.fetch = mock.fn(async () => ({
        ok: false,
        status: 400,
        statusText: 'Bad Request',
        json: async () => ({ message: 'Client ID is required' }),
      })) as any;

      const payload: CreateTicketPayload = {
        clientId: 0, // Invalid client ID
        contactId: 42,
        description: "Test",
        notes: "",
        state: "open",
        timeEntry: {
          workDate: "2025-10-11",
          durationHours: 0.5,
          billable: true,
        },
      };

      await assert.rejects(
        async () => await createTicket(payload),
        {
          message: /Client ID is required/,
        }
      );
    });
    ```
  - [ ] Run tests: `NODE_OPTIONS="--no-warnings" node --test outlook-addin/src/lib/api/__tests__/tickets.test.ts`
  - [ ] Verify all 5 test cases pass
  - [ ] [Source: [testing-strategy.md#unit-tests-for-backend-matching](../architecture/testing-strategy.md#unit-tests-for-backend-matching), Node test runner patterns from backend tests]

- [x] **Task 6: TypeScript Compilation and Linting** (AC: All)
  - [ ] Run TypeScript compilation: `npx tsc --noEmit` from outlook-addin directory
  - [ ] Verify no type errors in new files (api-client.ts, tickets.ts, TicketForm.tsx, App.tsx)
  - [ ] Run linting: `npm run lint` from outlook-addin directory
  - [ ] Fix any ESLint errors or warnings
  - [ ] [Source: [coding-standards-and-integration-rules.md#typescript-standards](../architecture/coding-standards-and-integration-rules.md#typescript-standards)]

- [ ] **Task 7: Manual Testing in Outlook Web** (AC: 4, 5, 6, 7, 8)
  - [ ] Sideload add-in into Outlook Web and open task pane
  - [ ] **Test Case 1: Successful Ticket Creation (Existing Contact) (AC 4, 5, 6)**
    - Select email with existing contact match
    - Fill time: "15m", description: "Test ticket", notes: "End-to-end test"
    - Click "Create Ticket" button
    - Verify loading state: button disabled, spinner icon, text "Creating Ticket..."
    - Verify success message appears: "✓ Ticket #[ID] created successfully"
    - Verify form clears: description, notes, time reset to "2m"
    - Verify success message auto-dismisses after 3 seconds
    - Check database: Verify ticket created with correct data (contact ID, time entry, description)
  - [ ] **Test Case 2: Successful Ticket Creation (New Contact) (AC 8)**
    - Select email with domain match but no contact match
    - Edit contact name: "Jane Doe"
    - Fill time: "30m", description: "New contact ticket"
    - Click "Create Ticket" button
    - Verify loading state during submission
    - Verify success message appears
    - Check database: Verify new contact created with name "Jane Doe" and sender email
    - Check database: Verify ticket created with newly created contact ID
  - [ ] **Test Case 3: Authentication Error (AC 7)**
    - Clear session cookies (log out from backend)
    - Select email, fill form, submit
    - Verify error message: "Authentication required. Please log in to the web app."
    - Verify form data preserved (description, notes, time remain filled)
    - Verify submit button re-enabled for retry
  - [ ] **Test Case 4: Network Error (AC 7)**
    - Disconnect network or stop backend server
    - Select email, fill form, submit
    - Verify error message: "Network error. Check your connection and try again."
    - Verify form data preserved
    - Reconnect network, retry submission → Verify success
  - [ ] **Test Case 5: API Validation Error (AC 7)**
    - Manually trigger validation error (e.g., tamper with payload to send invalid clientId)
    - Verify error message displays backend's validation error
    - Verify submit button re-enabled for correction
  - [ ] **Test Case 6: Mark as Closed (AC 2)**
    - Select email, fill form, check "Mark as closed immediately" checkbox
    - Submit ticket
    - Check database: Verify ticket state is "closed"
  - [ ] Document test results in Dev Agent Record completion notes
  - [ ] [Source: [testing-strategy.md#manual-testing-for-add-in-ui](../architecture/testing-strategy.md#manual-testing-for-add-in-ui)]

## Dev Notes

### Previous Story Insights

**Story 5.1 (Ticket Form UI Components):**
- TicketForm component structure already in place: [outlook-addin/src/components/TicketForm.tsx](../../../outlook-addin/src/components/TicketForm.tsx)
- Form state management established: `useState` for description, notes, markAsClosed, selectedClient
- "Create Ticket" button exists with basic disabled state logic
- **Integration Point for Story 5.4:** Add `handleSubmit` function with real API call, loading state, error handling
- [Source: [5.1.ticket-form-ui-components.story.md](5.1.ticket-form-ui-components.story.md)]

**Story 5.2 (Time Entry Parsing & Validation):**
- Time parsing implemented: `parseTimeEntry` function converts formats (2h, 30m, 1h30m) to decimal hours
- Validation state management: `isTimeValid`, `parsedHours`, `timeError` state variables
- **Reuse for Story 5.4:** Include `parsedHours` in `timeEntry.durationHours` field of API payload
- [Source: [5.2.time-entry-parsing-validation.story.md](5.2.time-entry-parsing-validation.story.md)]

**Story 5.3 (New Contact Creation Workflow):**
- Contact state management: `contactName`, `contactEmail` state variables in App.tsx
- New contact validation: `contactNameError`, `contactEmailError` state variables in TicketForm
- Progressive disclosure logic: `matchingResult.type` determines whether to include `newContact` in payload
- **Critical for Story 5.4:** When `matchingResult?.type === 'domain-matched' || 'no-match'`, set `contactId: 0` and include `newContact` object in payload
- [Source: [5.3.new-contact-creation-workflow.story.md](5.3.new-contact-creation-workflow.story.md)]

**Stories 4.1-4.2 (Matching Logic Integration):**
- `matchingResult` state object contains client and contact data from API
- MatchingResult type: `{ type: 'contact-matched' | 'domain-matched' | 'no-match', client?: Client, contact?: Contact }`
- **Use in Story 5.4:** Determine `contactId` and whether to include `newContact` based on `matchingResult.type`
- [Source: Stories 4.1, 4.2, [outlook-addin/src/types.ts](../../../outlook-addin/src/types.ts)]

### API Client Architecture

**Centralized API Client Pattern:**
The `apiClient` utility function provides a reusable base for all API calls across the add-in. This pattern ensures consistent error handling, authentication, and request configuration.

**Key Features:**
- **Base URL Configuration:** Uses `VITE_API_URL` environment variable (default: `http://localhost:3001`)
- **Authentication:** Includes `credentials: 'include'` to send session cookies cross-origin
- **Error Handling:**
  - 401 Unauthorized → "Authentication required. Please log in to the web app."
  - Network errors (TypeError) → "Network error. Check your connection and try again."
  - Other HTTP errors → Parse error message from response body
- **Type Safety:** Generic type parameter `<T>` for response typing

**File Structure:**
```
outlook-addin/src/lib/
├── api-client.ts          # Base HTTP client with auth + error handling
└── api/
    ├── tickets.ts         # POST /api/tickets (Story 5.4)
    ├── matching.ts        # GET /api/contacts/match-email, GET /api/clients/match-domain (Stories 4.1, 4.2)
    └── clients.ts         # GET /api/clients (Story 4.4)
```

[Source: [source-tree-organization.md#new-file-organization](../architecture/source-tree-organization.md#new-file-organization), [coding-standards-and-integration-rules.md#api-integration](../architecture/coding-standards-and-integration-rules.md#api-integration)]

### Ticket Creation API Specification

**POST /api/tickets Endpoint:**
- **URL:** `https://ticketapi.zollc.com/api/tickets` (production) or `http://localhost:3001/api/tickets` (dev)
- **Method:** POST
- **Authentication:** Session cookies (httpOnly, secure, sameSite=none in production)
- **Content-Type:** application/json

**Request Payload (Existing Contact):**
```json
{
  "clientId": 5,
  "contactId": 42,
  "description": "Email support",
  "notes": "Helped with email configuration",
  "state": "closed",
  "timeEntry": {
    "workDate": "2025-10-11",
    "durationHours": 0.5,
    "billable": true
  }
}
```

**Request Payload (New Contact):**
```json
{
  "clientId": 5,
  "contactId": 0,
  "description": "Email support",
  "notes": "New contact from domain match",
  "state": "open",
  "timeEntry": {
    "workDate": "2025-10-11",
    "durationHours": 0.5,
    "billable": true
  },
  "newContact": {
    "name": "Jane Doe",
    "email": "jane.doe@acme.com"
  }
}
```

**Response (Success):**
```json
{
  "id": 123,
  "clientId": 5,
  "contactId": 42,
  "description": "Email support",
  "state": "closed",
  "createdAt": "2025-10-11T12:00:00Z"
}
```

**Error Responses:**
- **401 Unauthorized:** Session expired or user not authenticated
- **400 Bad Request:** Validation errors (missing required fields, invalid data types)
- **500 Internal Server Error:** Backend processing error

**Critical Payload Rules:**
1. `contactId: 0` signals new contact creation → MUST include `newContact` object
2. `contactId > 0` uses existing contact → MUST NOT include `newContact` object
3. `timeEntry.workDate` MUST be ISO date format (YYYY-MM-DD)
4. `timeEntry.durationHours` MUST be decimal hours (e.g., 0.5 for 30 minutes)
5. `timeEntry.billable` MUST be `true` (all add-in tickets billable by default)
6. `state` MUST be either `'open'` or `'closed'` (lowercase)

[Source: [api-design-and-integration.md#post-api-tickets](../architecture/api-design-and-integration.md#post-api-tickets), [coding-standards-and-integration-rules.md#critical-integration-rules](../architecture/coding-standards-and-integration-rules.md#critical-integration-rules)]

### Form State Management and Submission Flow

**TicketForm Component State (from Stories 5.1-5.3):**
```typescript
// Form field state
const [description, setDescription] = useState<string>("");
const [notes, setNotes] = useState<string>("");
const [markAsClosed, setMarkAsClosed] = useState<boolean>(false);
const [timeInput, setTimeInput] = useState<string>("2m");

// Validation state (Stories 5.2, 5.3)
const [timeError, setTimeError] = useState<string>("");
const [isTimeValid, setIsTimeValid] = useState<boolean>(true);
const [parsedHours, setParsedHours] = useState<number | null>(0.03);
const [contactNameError, setContactNameError] = useState<string>("");

// NEW for Story 5.4: Submission state
const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
const [submitError, setSubmitError] = useState<string>("");
```

**Submission Flow:**
1. User clicks "Create Ticket" button → `handleSubmit` triggered (AC 4)
2. Client-side validation runs (Stories 5.2, 5.3 validation logic)
3. If validation fails → Display inline error, stop submission
4. If validation passes → Set `isSubmitting = true` (AC 5)
5. Build `CreateTicketPayload` object (AC 2)
   - Determine `contactId` from `matchingResult.type`
   - Include `newContact` if `contactId === 0` (AC 8)
   - Use `parsedHours` for `timeEntry.durationHours`
   - Use current date for `timeEntry.workDate`
6. Call `createTicket(payload)` API function (AC 1)
7. **On Success:**
   - Set `isSubmitting = false`
   - Call `onSubmit(response)` callback → Parent (App.tsx) displays success banner (AC 6)
   - Parent clears form state (AC 6)
8. **On Error:**
   - Set `isSubmitting = false`
   - Set `submitError` with error message (AC 7)
   - Display error below submit button (AC 7)
   - Form data preserved for retry (AC 7)

**Button Disabled States:**
```typescript
const isFormValid = selectedClient !== null
  && isTimeValid
  && parsedHours !== null
  && (matchingResult?.type === 'contact-matched' ||
      (contactName.trim().length > 0 && contactEmail.trim().length > 0));

// Button disabled if:
// 1. Form invalid (client not selected, time invalid, contact missing)
// 2. Currently submitting (isSubmitting === true)
const buttonDisabled = !isFormValid || isSubmitting;
```

[Source: Story 5.1, 5.2, 5.3 patterns, [component-architecture.md#ticketform](../architecture/component-architecture.md#ticketform)]

### Success Handling and Form Reset

**App.tsx Callback Pattern:**
```typescript
const handleTicketSubmit = (response: CreateTicketResponse) => {
  // Set ticket ID for success banner
  setCreatedTicketId(response.id);

  // Clear all form state
  setDescription("");
  setNotes("");
  setMarkAsClosed(false);
  setContactName("");
  setContactEmail("");
  setSelectedClient(null);

  // TicketForm resets timeInput to "2m" via internal state
};

const handleDismissSuccess = () => {
  setCreatedTicketId(null);
};
```

**Success Banner Component Usage:**
```tsx
{createdTicketId && (
  <SuccessBanner
    ticketId={createdTicketId}
    showLink={false}
    onDismiss={handleDismissSuccess}
  />
)}
```

**SuccessBanner Component Details:**
- **Component:** Existing SuccessBanner at [outlook-addin/src/components/SuccessBanner.tsx](../../../outlook-addin/src/components/SuccessBanner.tsx)
- **Props:** `ticketId` (number), `showLink` (boolean, use `false` for add-in), `onDismiss` (callback)
- **Icon:** Text checkmark "✓" with Lucide `X` icon for dismiss button
- **Auto-dismiss:** Built-in 3-second timer (handled by component's useEffect)
- **Positioning:** Render at top of form (before EmailContext component)
- **Accessibility:** Component includes ARIA attributes and focus management

**Note on "Reset to Next Email" (AC 6):**
The AC mentions "reset to next email" which is actually the scope of **Story 5.7: Form Auto-Clear on Email Change**. For Story 5.4, we implement form clearing but the form stays on the same email. Story 5.7 will add Office.js event listener to detect email changes and trigger form reset.

[Source: [outlook-addin/src/components/SuccessBanner.tsx](../../../outlook-addin/src/components/SuccessBanner.tsx), Story 5.1 App.tsx patterns]

### Error Handling Strategy

**Error Categories and Messages:**

1. **Client-Side Validation Errors (pre-submission):**
   - "Client selection required" → `validationError` state
   - "Contact name is required" → `contactNameError` state
   - "Invalid time format. Examples: 2h, 30m, 1.5h" → `timeError` state
   - Displayed inline next to respective fields (red text, `text-red-600`)

2. **Authentication Errors (401):**
   - Message: "Authentication required. Please log in to the web app."
   - Cause: Session expired or user not logged in
   - User Action: Open web app, log in, return to add-in, retry

3. **Network Errors:**
   - Message: "Network error. Check your connection and try again."
   - Cause: No internet connection, backend server down, CORS failure
   - User Action: Check network connection, retry

4. **API Validation Errors (400):**
   - Message: Parse error message from backend response (e.g., "Client ID is required")
   - Cause: Backend validation failed (edge case, should be caught by client-side validation)
   - User Action: Correct field values, retry

5. **Server Errors (500):**
   - Message: "Server error. Please try again later."
   - Cause: Backend processing error (database error, unexpected exception)
   - User Action: Wait, retry

**Error Display:**
- Submit errors displayed below "Create Ticket" button (not inline)
- Red text (`text-red-600`), small font (`text-sm`)
- Error persists until next submission attempt or form change
- Form data preserved on error (user can correct and retry without losing work)

**Error Handling in `apiClient`:**
```typescript
if (!response.ok) {
  if (response.status === 401) {
    throw new Error('Authentication required. Please log in to the web app.');
  }

  const errorData = await response.json().catch(() => ({}));
  throw new Error(errorData.message || `HTTP ${response.status}: ${response.statusText}`);
}
```

[Source: [coding-standards-and-integration-rules.md#error-handling](../architecture/coding-standards-and-integration-rules.md#error-handling), Story 5.2, 5.3 validation patterns]

### TypeScript Types and Interfaces

**Existing Types (from previous stories):**
```typescript
// outlook-addin/src/types.ts
export interface Client {
  id: number;
  name: string;
}

export interface Contact {
  id: number;
  name: string;
  email: string;
  clientId: number;
}

export type MatchingResultType = 'contact-matched' | 'domain-matched' | 'no-match';

export interface MatchingResult {
  type: MatchingResultType;
  client?: Client;
  contact?: Contact;
}
```

**New Types for Story 5.4:**
```typescript
// outlook-addin/src/lib/api/tickets.ts
export interface TimeEntryData {
  workDate: string; // ISO date format YYYY-MM-DD
  durationHours: number; // Decimal hours
  billable: boolean;
}

export interface NewContactData {
  name: string;
  email: string;
}

export interface CreateTicketPayload {
  clientId: number;
  contactId: number;
  description: string;
  notes: string;
  state: 'open' | 'closed';
  timeEntry: TimeEntryData;
  newContact?: NewContactData; // Optional, only when contactId === 0
}

export interface CreateTicketResponse {
  id: number;
  clientId: number;
  contactId: number;
  description: string;
  state: string;
  createdAt: string;
}
```

**Type Import Pattern:**
```typescript
// In TicketForm.tsx
import { CreateTicketPayload } from '../lib/api/tickets';
import { MatchingResult, Client } from '../types';
```

[Source: [coding-standards-and-integration-rules.md#typescript-standards](../architecture/coding-standards-and-integration-rules.md#typescript-standards), [outlook-addin/src/types.ts](../../../outlook-addin/src/types.ts)]

### Testing

#### Testing Standards

**Unit Tests (AC 9):**
- **Framework:** Node.js built-in test runner (`node:test`)
- **Location:** [outlook-addin/src/lib/api/__tests__/tickets.test.ts](../../../outlook-addin/src/lib/api/__tests__/tickets.test.ts)
- **Coverage:** 5 test cases covering success, new contact, 401, network error, 400 validation error
- **Mocking:** Mock `global.fetch` using `node:test` `mock.fn()`
- **Run Command:** `NODE_OPTIONS="--no-warnings" node --test outlook-addin/src/lib/api/__tests__/tickets.test.ts`
- **Assertion Library:** `node:assert` (strictEqual, rejects)

**Manual Testing (AC 4, 5, 6, 7, 8):**
- **Environment:** Outlook Web (Chrome, Safari on macOS)
- **Scenarios:** 6 test cases covering successful submission (existing/new contact), auth error, network error, validation error, mark as closed
- **Focus:** End-to-end ticket creation flow, loading states, success messages, error handling, form reset, database verification

**No E2E Tests:**
- Office Add-in E2E testing requires complex Outlook automation not justified for MVP timeline
- Manual testing in real Outlook Web environment provides sufficient coverage

[Source: [testing-strategy.md#unit-tests-for-backend-matching](../architecture/testing-strategy.md#unit-tests-for-backend-matching), [testing-strategy.md#manual-testing-for-add-in-ui](../architecture/testing-strategy.md#manual-testing-for-add-in-ui)]

#### Manual Testing Prerequisites

**Test Environment Setup:**
1. Backend running at `http://localhost:3001` with session authentication enabled
2. Database with test clients and contacts:
   - Client "Acme Corp" (ID: 5) with domain "acme.com" and contact "John Smith" (ID: 42, email: "john.smith@acme.com")
   - Client "Test Client" (ID: 1) with domain "test.com" but no contacts
3. Add-in sideloaded in Outlook Web with task pane open
4. User authenticated in backend (session cookie valid)

**CORS Configuration Required:**
- Backend CORS must allow add-in origin: `http://localhost:5173` (dev) or `https://outlook-addin.zollc.com` (prod)
- Session cookies must have `SameSite=None; Secure` in production for cross-origin access

**Test Data Preparation:**
- Outlook inbox with test emails:
  - Email from "john.smith@acme.com" (existing contact match)
  - Email from "jane.doe@acme.com" (domain match, new contact)
  - Email from "unknown@unknown.com" (no match)

[Source: [testing-strategy.md#manual-testing-for-add-in-ui](../architecture/testing-strategy.md#manual-testing-for-add-in-ui), [api-design-and-integration.md#cors-configuration](../architecture/api-design-and-integration.md#cors-configuration)]

### Tech Stack and Standards

**TypeScript Standards:**
- Use `import.meta.env.VITE_API_URL` for environment variable access (Vite pattern)
- All API functions return `Promise<T>` with explicit return types
- Use `RequestInit` type for fetch options
- Use strict null checks (`contactId: number`, not `contactId?: number`)

**React Patterns:**
- Async event handlers: `const handleSubmit = async (e: FormEvent) => { ... }`
- Loading state with `useState<boolean>(false)` pattern
- Error state with `useState<string>("")` pattern
- Callback props: `onSubmit: (response: CreateTicketResponse) => void`

**Fetch API:**
- Use native `fetch` (no axios or other HTTP client needed)
- Include `credentials: 'include'` for session cookies
- Parse JSON responses with `await response.json()`
- Handle non-OK responses before parsing JSON

**Tailwind CSS:**
- Button disabled state: `bg-gray-300 text-gray-500 cursor-not-allowed`
- Button loading state: Spinner icon (`Loader2` from Lucide) with `animate-spin`
- Success banner: `bg-green-50 border-green-200 text-green-800`
- Error text: `text-red-600 text-sm`

[Source: [tech-stack.md](../architecture/tech-stack.md), [coding-standards-and-integration-rules.md](../architecture/coding-standards-and-integration-rules.md)]

### File Locations Summary

**New Files Created in Story 5.4:**
- [outlook-addin/src/lib/api-client.ts](../../../outlook-addin/src/lib/api-client.ts) - Base HTTP client utility
- [outlook-addin/src/lib/api/tickets.ts](../../../outlook-addin/src/lib/api/tickets.ts) - Ticket API service module
- [outlook-addin/src/lib/api/__tests__/tickets.test.ts](../../../outlook-addin/src/lib/api/__tests__/tickets.test.ts) - Unit tests for ticket API

**Modified Files in Story 5.4:**
- [outlook-addin/src/components/TicketForm.tsx](../../../outlook-addin/src/components/TicketForm.tsx) - Add submission logic, loading state, error handling
- [outlook-addin/src/App.tsx](../../../outlook-addin/src/App.tsx) - Add success handling, form reset callback

**No Changes:**
- [outlook-addin/src/components/EmailContext.tsx](../../../outlook-addin/src/components/EmailContext.tsx) - No changes needed
- [outlook-addin/src/types.ts](../../../outlook-addin/src/types.ts) - Existing types sufficient (Client, Contact, MatchingResult)

[Source: [source-tree-organization.md#new-file-organization](../architecture/source-tree-organization.md#new-file-organization)]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-11 | 1.0 | Initial story creation - Ticket submission to backend API with authentication, loading states, error handling, and new contact creation | Bob (Scrum Master) |
| 2025-10-11 | 1.1 | Story validation corrections: Updated Task 4 to use existing SuccessBanner component instead of inline JSX, corrected Dev Notes icon reference, added explicit import instructions for Loader2 and CreateTicketResponse type. Status changed to Approved. | Sarah (Product Owner) |

## Dev Agent Record

### Agent Model Used

claude-sonnet-4-5-20250929

### Debug Log References

None - no blocking issues encountered.

### Completion Notes List

1. **Adapted to existing backend API**: The story spec assumed an API that accepts `durationHours` and inline `newContact` creation. The actual backend uses `duration` and requires separate API calls for contact creation. Implemented adapter pattern in `createTicket()` function that:
   - Creates contact via `POST /api/contacts` if `contactId === 0`
   - Creates ticket via `POST /api/tickets` with actual `contactId`
   - Sets state to 'closed' via `PUT /api/tickets/:id` if requested

2. **Test environment handling**: Added safe navigation for `import.meta.env` to support Node.js test runner environment (changed `import.meta.env.VITE_API_URL` to `(typeof import.meta !== 'undefined' && import.meta.env?.VITE_API_URL)`).

3. **Unit tests**: All 5 test cases pass successfully using tsx + Node test runner:
   - Existing contact ticket creation
   - New contact ticket creation (verifies contact API called first)
   - 401 authentication error
   - Network error handling
   - 400 validation error

4. **Linting**: Fixed TypeScript linting warnings by replacing `as any` casts with proper type annotations (`as typeof global.fetch`, `as Response`).

5. **TypeScript compilation**: Clean compilation with no errors.

6. **Manual testing**: Task 7 requires live Outlook Web environment with backend running. Implementation is complete and ready for QA validation.

### File List

**New files created:**
- `outlook-addin/src/lib/api-client.ts` - Base HTTP client with authentication and error handling
- `outlook-addin/src/lib/api/tickets.ts` - Ticket API service with createTicket function and TypeScript interfaces
- `outlook-addin/src/lib/api/__tests__/tickets.test.ts` - Unit tests for ticket creation API (5 test cases, all passing)

**Modified files:**
- `outlook-addin/src/components/TicketForm.tsx` - Added API integration, loading states, submit error handling
- `outlook-addin/src/App.tsx` - Added success banner display and form reset on successful submission

## QA Results

(To be filled by QA Agent after implementation)
