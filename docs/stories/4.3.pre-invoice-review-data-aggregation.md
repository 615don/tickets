# Story 4.3: Pre-Invoice Review Data Aggregation

## Status
**Ready for Review**

## Story
**As a** developer,
**I want** backend logic to aggregate tickets by month for invoice review,
**so that** the frontend can display pre-invoice summary (FR16).

## Acceptance Criteria
1. API endpoint `GET /api/invoices/preview?month=YYYY-MM` returns invoice preview data
2. Response groups tickets by client with subtotals per client
3. Response includes total billable hours across all clients for the month
4. Response flags tickets missing descriptions (per FR3 requirement)
5. Calculation includes all time entries with work_date in specified month
6. Calculation sums duration_hours for billable time entries only
7. Non-billable tickets included in data with $0 amount calculated (FR15)
8. Endpoint validates month is not already locked (return lock status in response)
9. Response format structured for easy UI rendering (client grouping, line item details)
10. Endpoint requires authentication

## Tasks / Subtasks

- [x] Task 1: Create invoice controller and route (AC: 1, 10)
  - [x] Create `backend/src/controllers/invoiceController.js` following existing controller pattern
  - [x] Implement `previewInvoice` handler function
  - [x] Add authentication middleware to route
  - [x] Create route file `backend/src/routes/invoices.js` with `GET /preview` endpoint
  - [x] Register invoice routes in `backend/src/index.js` at `/api/invoices`
  - [x] Add request validation: month parameter format YYYY-MM (express-validator)

- [x] Task 2: Implement month lock status validation (AC: 8)
  - [x] Import InvoiceLock model from Story 4.2
  - [x] Call `InvoiceLock.isMonthLocked(month)` to check lock status
  - [x] Include lock status in response: `{ isLocked: boolean }`
  - [x] If locked, still return preview data but mark as read-only

- [x] Task 3: Build SQL query for time entry aggregation (AC: 5, 6)
  - [x] Query time_entries table with filter: `work_date >= 'YYYY-MM-01' AND work_date < 'YYYY-MM+1-01'`
  - [x] Include soft-delete filter: `WHERE deleted_at IS NULL`
  - [x] JOIN with tickets table to get ticket details (id, description, client_id, contact_id)
  - [x] JOIN with clients table to get client names
  - [x] JOIN with contacts table to get contact names
  - [x] Select fields: time_entry_id, work_date, duration_hours, billable, ticket_id, ticket.description, client_id, client_name, contact_id, contact_name, missing_description flag
  - [x] **DO NOT use GROUP BY** - fetch individual time entries for proper handling of mixed billable/non-billable tickets
  - [x] ORDER BY client_name, ticket_id, work_date for logical grouping in JavaScript
  - [x] Use parameterized queries to prevent SQL injection

- [x] Task 4: Format response data with client grouping (AC: 2, 4, 9)
  - [x] Transform SQL results (individual time entries) into nested structure: clients → tickets → time entries
  - [x] Group time entries by client_id, then by ticket_id
  - [x] For each ticket, aggregate time entries to calculate:
    - `totalHours`: Sum of ALL time entry duration_hours (billable + non-billable)
    - `billableHours`: Sum of only billable time entry duration_hours
    - `nonBillableHours`: Sum of only non-billable time entry duration_hours
  - [x] Determine ticket billable status: ticket is "billable" if billableHours > 0 (even if it also has non-billable hours)
  - [x] Calculate per-client subtotals: sum of billable hours only for all tickets per client
  - [x] Flag tickets with `description IS NULL` or empty string (already in SQL result as missing_description)
  - [x] Include full timeEntries array in each ticket for detailed breakdown
  - [x] Structure response format matches specification

- [x] Task 5: Handle mixed billable/non-billable and pure non-billable tickets (AC: 7)
  - [x] Include ALL tickets in response data regardless of billable status
  - [x] For tickets with ONLY non-billable time entries: set billable: false, billableHours: 0
  - [x] For tickets with MIXED entries: set billable: true (since they have some billable hours), include both billableHours and nonBillableHours
  - [x] For tickets with ONLY billable entries: set billable: true, nonBillableHours: 0
  - [x] Non-billable hours NOT included in totalBillableHours or client subtotals (only billableHours counted)
  - [x] All tickets flagged if missing descriptions (FR3 applies to all tickets regardless of billable status)

- [x] Task 6: Calculate total billable hours across all clients (AC: 3)
  - [x] Sum all billable hours from all clients after grouping
  - [x] Exclude non-billable hours from total
  - [x] Return as top-level field: `totalBillableHours`
  - [x] Use JavaScript reduce or SQL SUM with billable filter

- [x] Task 7: Add error handling and edge cases (AC: 1, 10)
  - [x] Validate month parameter format (YYYY-MM) using express-validator with regex `^\d{4}-\d{2}$`
  - [x] Validate month value is between 01-12 (semantic validation)
  - [x] Validate year is reasonable (e.g., between 2020-2099)
  - [x] Return 400 error if month format or value invalid
  - [x] Return 401 error if not authenticated (middleware handles this)
  - [x] Handle case where no time entries exist for month (return empty clients array)
  - [x] Handle database errors gracefully (500 error with standard format)

- [x] Task 8: Manual testing and verification (AC: All)
  - [x] Create test data: multiple tickets across different clients for a specific month
  - [x] Include pure billable tickets (all entries billable)
  - [x] Include pure non-billable tickets (all entries non-billable)
  - [x] Include mixed tickets (some billable, some non-billable entries)
  - [x] Include tickets with and without descriptions
  - [x] Test via Postman or curl: `GET /api/invoices/preview?month=2025-09`
  - [x] Verify response structure matches updated AC 9 format (includes billableHours, nonBillableHours)
  - [x] Verify totalBillableHours excludes non-billable entries
  - [x] Verify client subtotalHours only counts billable hours
  - [x] Verify mixed tickets show correct billable/nonBillable breakdown
  - [x] Verify missingDescription flag works correctly
  - [x] Test invalid month values: `month=2025-13`, `month=2025-00` (should fail validation)
  - [x] Test locked month scenario (create invoice lock for month, verify isLocked: true)
  - [x] Verify authentication requirement (test without session cookie)

## Dev Notes

### Previous Story Context

**From Story 4.2 (Invoice Lock Mechanism):**
- InvoiceLock model available at `backend/src/models/InvoiceLock.js`
- Method: `InvoiceLock.isMonthLocked(month)` returns boolean
- Month format: YYYY-MM-01 (normalize from YYYY-MM parameter)
- Utility function `extractMonth(workDate)` available at `backend/src/utils/invoiceLock.js`
- Lock validation returns 403 error when modifications attempted

**From Story 3.5 (Ticket Update & Time Entry Management API):**
- Time entry endpoints use soft delete pattern (deleted_at timestamp)
- Time entries table has columns: id, ticket_id, work_date (DATE), duration_hours (DECIMAL), billable (BOOLEAN), deleted_at
- Existing time entry controller: `backend/src/controllers/timeEntryController.js`

**From Story 3.4 (Ticket Retrieval API):**
- Ticket model pattern uses repository pattern with methods in `backend/src/models/Ticket.js`
- Existing endpoints return tickets with JOINed client/contact names
- Controller pattern: `backend/src/controllers/ticketController.js`

### Data Models

**InvoicePreview Response Structure** [Source: PRD Epic 4, Story 4.3 AC 9]

```typescript
interface InvoicePreviewResponse {
  month: string; // YYYY-MM format
  isLocked: boolean; // Whether month has invoice lock
  totalBillableHours: number; // Sum of billable hours only across all clients
  clients: InvoicePreviewClient[];
}

interface InvoicePreviewClient {
  clientId: number;
  clientName: string;
  subtotalHours: number; // Sum of billable hours only for this client
  tickets: InvoicePreviewTicket[];
}

interface InvoicePreviewTicket {
  ticketId: number;
  description: string | null;
  contactId: number;
  contactName: string;
  totalHours: number; // Sum of ALL time entries (billable + non-billable)
  billableHours: number; // Sum of billable time entries only
  nonBillableHours: number; // Sum of non-billable time entries only
  billable: boolean; // True if ticket has ANY billable hours (billableHours > 0)
  missingDescription: boolean; // True if description is null or empty
  timeEntries: TimeEntrySummary[]; // Full detailed breakdown
}

interface TimeEntrySummary {
  id: number;
  workDate: string; // YYYY-MM-DD
  durationHours: number;
  billable: boolean;
}
```

**CRITICAL:** Tickets can have mixed billable and non-billable time entries:
- A ticket with 3 billable hours and 2 non-billable hours: `totalHours: 5, billableHours: 3, nonBillableHours: 2, billable: true`
- A pure non-billable ticket: `totalHours: 2, billableHours: 0, nonBillableHours: 2, billable: false`
- Client subtotals and totalBillableHours count ONLY billableHours

**Key Business Rules:**
- Invoices aggregate by `work_date` month, NOT ticket creation date (supports multi-month tickets)
- Only active time entries included (`deleted_at IS NULL`)
- Tickets with ANY billable hours included in totals; pure non-billable tickets excluded from totals
- Mixed billable/non-billable tickets: count only billableHours in subtotals and grand total
- All tickets must have descriptions before invoicing (FR3) - flag missing ones

### Database Schema

**Relevant Tables and Columns** [Source: docs/architecture/database-schema.md]

```sql
-- Time Entries (primary aggregation source)
time_entries (
  id SERIAL PRIMARY KEY,
  ticket_id INTEGER REFERENCES tickets(id),
  work_date DATE NOT NULL,          -- Filter by month
  duration_hours DECIMAL(5,2) NOT NULL,
  billable BOOLEAN DEFAULT true,
  deleted_at TIMESTAMP,             -- Soft delete filter
  created_at TIMESTAMP,
  updated_at TIMESTAMP
);
CREATE INDEX idx_time_entries_work_date ON time_entries(work_date);

-- Tickets (for description and client/contact relationships)
tickets (
  id SERIAL PRIMARY KEY,
  client_id INTEGER REFERENCES clients(id),
  contact_id INTEGER REFERENCES contacts(id),
  description TEXT,                 -- Flag if NULL or empty
  notes TEXT,
  state VARCHAR(10),
  closed_at TIMESTAMP,
  created_at TIMESTAMP,
  updated_at TIMESTAMP
);

-- Clients (for grouping and names)
clients (
  id SERIAL PRIMARY KEY,
  company_name VARCHAR(255) NOT NULL,
  xero_customer_id VARCHAR(255),
  ...
);

-- Contacts (for contact names in ticket details)
contacts (
  id SERIAL PRIMARY KEY,
  client_id INTEGER REFERENCES clients(id),
  name VARCHAR(255) NOT NULL,
  email VARCHAR(255),
  ...
);

-- Invoice Locks (for lock status check)
invoice_locks (
  id SERIAL PRIMARY KEY,
  month DATE UNIQUE NOT NULL,       -- Check if month is locked
  locked_at TIMESTAMP,
  xero_invoice_ids JSONB
);
CREATE INDEX idx_invoice_locks_month ON invoice_locks(month);
```

### API Specifications

**GET /api/invoices/preview?month=YYYY-MM** [Source: docs/architecture/api-specification.md]

**Request:**
- Query Parameter: `month` (required, format: YYYY-MM)
- Authentication: Required (session-based)

**Response (200 OK):**
```json
{
  "month": "2025-09",
  "isLocked": false,
  "totalBillableHours": 42.5,
  "clients": [
    {
      "clientId": 1,
      "clientName": "Acme Corp",
      "subtotalHours": 12.5,
      "tickets": [
        {
          "ticketId": 42,
          "description": "Fix login bug",
          "contactId": 5,
          "contactName": "John Doe",
          "totalHours": 7.0,
          "billableHours": 5.5,
          "nonBillableHours": 1.5,
          "billable": true,
          "missingDescription": false,
          "timeEntries": [
            {
              "id": 101,
              "workDate": "2025-09-15",
              "durationHours": 2.5,
              "billable": true
            },
            {
              "id": 102,
              "workDate": "2025-09-16",
              "durationHours": 3.0,
              "billable": true
            },
            {
              "id": 103,
              "workDate": "2025-09-17",
              "durationHours": 1.5,
              "billable": false
            }
          ]
        }
      ]
    }
  ]
}
```

**Error Responses:**

**400 Bad Request** (invalid month format):
```json
{
  "error": "ValidationError",
  "message": "Invalid month format. Expected YYYY-MM."
}
```

**401 Unauthorized** (not authenticated):
```json
{
  "error": "AuthenticationError",
  "message": "Authentication required"
}
```

**500 Internal Server Error** (database error):
```json
{
  "error": "DatabaseError",
  "message": "Failed to retrieve invoice preview"
}
```

### File Locations

[Source: docs/architecture/unified-project-structure.md]

**Backend Files to Create:**
- Controller: `backend/src/controllers/invoiceController.js` (CREATE)
- Routes: `backend/src/routes/invoiceRoutes.js` (CREATE)

**Backend Files to Modify:**
- Entry Point: `backend/src/index.js` (MODIFY - register invoice routes)

**Existing Patterns to Follow:**
- Controller pattern: `backend/src/controllers/ticketController.js` (repository pattern, error handling)
- Route pattern: `backend/src/routes/ticketRoutes.js` (authentication middleware, express-validator)
- Model pattern: `backend/src/models/InvoiceLock.js` (already exists, import and use)

### Tech Stack

[Source: docs/architecture/tech-stack.md]

**Backend Stack:**
- **Backend Framework:** Express ^4.18.2
- **Database:** PostgreSQL 14+
- **Validation:** express-validator ^7.0.1
- **Testing:** Node test runner (manual testing for MVP, unit tests for critical logic)

**Query Features:**
- **JOINs:** Multiple table joins for client/contact names
- **GROUP BY:** Aggregate time entries by ticket
- **DATE filtering:** work_date >= 'YYYY-MM-01' AND work_date < 'YYYY-MM+1-01'
- **Indexes:** idx_time_entries_work_date for fast month filtering

### Coding Standards

[Source: docs/architecture/coding-standards.md]

**Critical Rules:**
- **Environment Variables:** Access via config, never `process.env` directly
- **Error Handling:** All API routes use standard error format `{ error: "ErrorType", message: "..." }`
- **Parameterized Queries:** Always use parameterized queries to prevent SQL injection
- **State Updates:** Never mutate state directly

**Naming Conventions:**
- **API Routes:** kebab-case → `/api/invoices/preview`
- **Database Tables:** snake_case → `time_entries`, `invoice_locks`
- **Controller Files:** camelCase → `invoiceController.js`

### SQL Query Pattern

**Time Entry Aggregation Query Example:**

**CRITICAL:** Tickets can have mixed billable and non-billable time entries. The query must fetch individual time entries to allow proper aggregation in JavaScript.

```sql
SELECT
  te.id AS time_entry_id,
  te.work_date,
  te.duration_hours,
  te.billable,
  t.id AS ticket_id,
  t.description,
  t.client_id,
  c.company_name AS client_name,
  t.contact_id,
  ct.name AS contact_name,
  CASE WHEN t.description IS NULL OR t.description = '' THEN true ELSE false END AS missing_description
FROM time_entries te
JOIN tickets t ON te.ticket_id = t.id
JOIN clients c ON t.client_id = c.id
JOIN contacts ct ON t.contact_id = ct.id
WHERE
  te.work_date >= $1               -- Start of month (YYYY-MM-01)
  AND te.work_date < $2            -- Start of next month (YYYY-MM+1-01)
  AND te.deleted_at IS NULL        -- Exclude soft-deleted entries
ORDER BY c.company_name, t.id, te.work_date;
```

**Why No GROUP BY:** Since tickets can have mixed billable/non-billable entries, we fetch all time entries individually and aggregate in JavaScript. This allows us to:
1. Calculate total hours (all entries) per ticket
2. Calculate billable hours separately per ticket
3. Determine if ticket is primarily billable (majority of hours)
4. Include detailed time entry breakdown in response

**Month Boundary Calculation:**
```javascript
// Input: month = "2025-09"
const startDate = `${month}-01`;           // "2025-09-01"
const nextMonth = new Date(`${month}-01`);
nextMonth.setMonth(nextMonth.getMonth() + 1);
const endDate = nextMonth.toISOString().substring(0, 10); // "2025-10-01"

// Query: WHERE work_date >= '2025-09-01' AND work_date < '2025-10-01'
```

### Controller Implementation Pattern

[Source: backend/src/controllers/ticketController.js, backend/src/controllers/clientController.js]

```javascript
// backend/src/controllers/invoiceController.js
const pool = require('../config/database');
const InvoiceLock = require('../models/InvoiceLock');
const { validationResult } = require('express-validator');

const invoiceController = {
  async previewInvoice(req, res) {
    try {
      // Validate request
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          error: 'ValidationError',
          message: errors.array()[0].msg
        });
      }

      const { month } = req.query;

      // Check lock status
      const isLocked = await InvoiceLock.isMonthLocked(`${month}-01`);

      // Calculate month boundaries
      const startDate = `${month}-01`;
      const nextMonth = new Date(startDate);
      nextMonth.setMonth(nextMonth.getMonth() + 1);
      const endDate = nextMonth.toISOString().substring(0, 10);

      // Query time entries with joins
      const result = await pool.query(
        `SELECT ... FROM time_entries ... WHERE work_date >= $1 AND work_date < $2 ...`,
        [startDate, endDate]
      );

      // Transform and group data
      const clients = groupByClient(result.rows);
      const totalBillableHours = calculateTotalBillable(result.rows);

      res.json({
        month,
        isLocked,
        totalBillableHours,
        clients
      });
    } catch (error) {
      console.error('Error previewing invoice:', error);
      res.status(500).json({
        error: 'DatabaseError',
        message: 'Failed to retrieve invoice preview'
      });
    }
  }
};

module.exports = invoiceController;
```

### Route Implementation Pattern

[Source: backend/src/routes/ticketRoutes.js]

```javascript
// backend/src/routes/invoiceRoutes.js
const express = require('express');
const router = express.Router();
const { query } = require('express-validator');
const invoiceController = require('../controllers/invoiceController');

// GET /api/invoices/preview?month=YYYY-MM
router.get(
  '/preview',
  [
    query('month')
      .matches(/^\d{4}-\d{2}$/)
      .withMessage('Invalid month format. Expected YYYY-MM.')
      .custom((value) => {
        const [year, month] = value.split('-').map(Number);
        if (month < 1 || month > 12) {
          throw new Error('Month must be between 01 and 12.');
        }
        if (year < 2020 || year > 2099) {
          throw new Error('Year must be between 2020 and 2099.');
        }
        return true;
      })
  ],
  invoiceController.previewInvoice
);

module.exports = router;
```

### Data Grouping Algorithm

**Transform flat SQL results (individual time entries) into nested client → tickets structure:**

```javascript
function groupByClient(rows) {
  const clientMap = new Map();
  const ticketMap = new Map();

  rows.forEach(row => {
    // Get or create client entry
    if (!clientMap.has(row.client_id)) {
      clientMap.set(row.client_id, {
        clientId: row.client_id,
        clientName: row.client_name,
        subtotalHours: 0,
        tickets: []
      });
    }

    const client = clientMap.get(row.client_id);
    const ticketKey = `${row.client_id}-${row.ticket_id}`;

    // Get or create ticket entry
    if (!ticketMap.has(ticketKey)) {
      const ticket = {
        ticketId: row.ticket_id,
        description: row.description,
        contactId: row.contact_id,
        contactName: row.contact_name,
        totalHours: 0,
        billableHours: 0,
        nonBillableHours: 0,
        billable: false, // Will be set to true if any billable hours found
        missingDescription: row.missing_description,
        timeEntries: []
      };
      ticketMap.set(ticketKey, ticket);
      client.tickets.push(ticket);
    }

    const ticket = ticketMap.get(ticketKey);

    // Add time entry to ticket
    const timeEntry = {
      id: row.time_entry_id,
      workDate: row.work_date,
      durationHours: parseFloat(row.duration_hours),
      billable: row.billable
    };
    ticket.timeEntries.push(timeEntry);

    // Aggregate hours
    const hours = parseFloat(row.duration_hours);
    ticket.totalHours += hours;

    if (row.billable) {
      ticket.billableHours += hours;
      ticket.billable = true; // Mark ticket as billable if any billable hours
      client.subtotalHours += hours; // Only billable hours count in subtotal
    } else {
      ticket.nonBillableHours += hours;
    }
  });

  return Array.from(clientMap.values());
}
```

**Key Changes for Mixed Billable/Non-Billable Support:**
1. Removed GROUP BY from SQL - fetch individual time entries
2. Group in JavaScript by client_id and ticket_id
3. Aggregate billableHours and nonBillableHours separately
4. Set ticket.billable = true if ANY billable hours exist (billableHours > 0)
5. Client subtotals count ONLY billableHours

### Multi-Month Ticket Handling

[Source: docs/architecture/api-specification.md]

**CRITICAL Business Rule:**
- Invoice preview filters by `work_date` month, NOT ticket creation date
- A ticket created in January with time entries in January AND February will appear in BOTH monthly previews
- January invoice preview shows only January time entries for that ticket
- February invoice preview shows only February time entries for that ticket
- After January invoice generation, January entries are locked; February entries remain editable

**Example:**
```
Ticket #42 created 2025-01-15:
  - Time entry 2025-01-20: 3 hours (billable)
  - Time entry 2025-02-05: 2 hours (billable)

January invoice preview (month=2025-01):
  - Ticket #42: 3 hours

February invoice preview (month=2025-02):
  - Ticket #42: 2 hours

After generating January invoices:
  - January time entry locked (cannot modify)
  - February time entry still editable
```

### Error Handling

[Source: docs/architecture/coding-standards.md]

**Standard Error Response Format:**
```json
{
  "error": "ErrorType",
  "message": "Human-readable explanation"
}
```

**HTTP Status Codes:**
- 200 OK - Success, invoice preview returned
- 400 Bad Request - Invalid month format or parameters
- 401 Unauthorized - Not authenticated (middleware handles)
- 500 Internal Server Error - Database or unexpected errors

**Error Types:**
- `ValidationError` - Invalid month format or parameters
- `AuthenticationError` - Not authenticated (middleware)
- `DatabaseError` - Database query failed

### Performance Considerations

[Source: docs/architecture/security-and-performance.md]

**Response Time Target:**
- **Goal:** <1000ms for invoice preview (complex aggregation acceptable)
- **Current Performance:** Index on work_date enables fast month filtering
- **Optimization:** Single query with JOINs reduces round trips

**Query Optimization:**
- Use `idx_time_entries_work_date` index for month filtering
- JOIN to reduce database round trips (fetch all data in single query)
- GROUP BY to aggregate time entries per ticket
- Specify only needed columns (avoid SELECT *)

**Connection Pooling:**
- Use existing pg pool from `backend/src/config/database.js`
- Max connections: 20 (sufficient for single-user MVP)

### Security Considerations

[Source: docs/architecture/security-and-performance.md]

**Authentication:**
- All invoice endpoints require authentication (session-based)
- Middleware validates session cookie before allowing access
- 401 error if not authenticated

**SQL Injection Prevention:**
- Use parameterized queries: `pool.query('SELECT ...', [param1, param2])`
- Never concatenate user input into SQL strings
- express-validator sanitizes month parameter before use

**Input Validation:**
- Month parameter: Must match regex `^\d{4}-\d{2}$` (YYYY-MM format)
- Sanitize input via express-validator before database operations
- Whitelist approach: Only allow expected query parameters

### Testing

[Source: docs/architecture/testing-strategy.md]

**Testing Approach:**
- **Manual Testing:** Required for MVP (via Postman/curl)
- **Unit Tests:** Future enhancement for groupByClient logic
- **Integration Tests:** Future enhancement for full endpoint testing

**Test Framework:** Node.js built-in test runner (no Jest/Vitest for MVP)

**Manual Testing Checklist:**
1. Create test data: multiple tickets across 2+ clients for target month
2. Include billable and non-billable time entries
3. Include tickets with and without descriptions
4. Test valid month format: `GET /api/invoices/preview?month=2025-09`
5. Test invalid month format: `GET /api/invoices/preview?month=09-2025` (should fail)
6. Test locked month scenario (create invoice lock, verify isLocked: true)
7. Test unauthenticated request (no session cookie, should return 401)
8. Test month with no time entries (should return empty clients array)
9. Verify response structure matches AC 9 format
10. Verify totalBillableHours excludes non-billable entries
11. Verify missingDescription flag works correctly
12. Verify client subtotals sum correctly

### Project Structure Alignment

[Source: docs/architecture/unified-project-structure.md]

All file paths align with established monorepo structure:
- Controllers: `backend/src/controllers/invoiceController.js`
- Routes: `backend/src/routes/invoiceRoutes.js`
- Entry Point: `backend/src/index.js` (register routes)

**No frontend changes required for this story** - this is pure backend API implementation. Frontend integration happens in Story 4.5.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-02 | 1.0 | Initial story creation | Bob (Scrum Master) |
| 2025-10-02 | 1.1 | Updated to properly handle mixed billable/non-billable time entries per ticket; enhanced month validation to check semantic validity (01-12, year range); added billableHours and nonBillableHours fields to response format; updated SQL query to fetch individual time entries instead of GROUP BY; updated data grouping algorithm to aggregate in JavaScript | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
claude-sonnet-4-5-20250929

### Debug Log References
None - no significant issues encountered during implementation

### Completion Notes List

**Implementation Summary:**
- Created invoice controller with comprehensive data aggregation logic for invoice preview
- Implemented month validation middleware with format and semantic checks
- Built SQL query that fetches individual time entries (no GROUP BY) to properly handle mixed billable/non-billable tickets
- Implemented JavaScript-based grouping algorithm that correctly calculates billable vs non-billable hours per ticket
- Fixed date boundary calculation bug (timezone issue with Date object) by using arithmetic instead of Date API
- All 10 acceptance criteria verified through manual testing

**Key Technical Decisions:**
1. **No GROUP BY in SQL**: Fetches individual time entries to allow proper aggregation of mixed billable/non-billable tickets in JavaScript
2. **Month boundary calculation**: Uses string arithmetic instead of Date object to avoid timezone-related bugs
3. **Validation placement**: Month validation in middleware layer for reusability
4. **Data structure**: Nested Map structures for efficient grouping by client and ticket

**Testing Coverage:**
- ✓ Valid month with mixed data (September 2025)
- ✓ Pure billable tickets
- ✓ Pure non-billable tickets
- ✓ Mixed billable/non-billable tickets
- ✓ Missing description flags
- ✓ Empty months (no data)
- ✓ Locked months
- ✓ Invalid formats (202509)
- ✓ Invalid month values (00, 13)
- ✓ Invalid year ranges
- ✓ Unauthenticated requests

**Challenges Resolved:**
1. Initial Date() calculation for month boundaries included timezone offset, causing October entries to appear in September results. Fixed by using pure arithmetic.
2. Ensured aggregation logic correctly separates billable and non-billable hours while maintaining ticket-level details.

### File List

**Created:**
- [backend/src/controllers/invoiceController.js](../../../backend/src/controllers/invoiceController.js) - Invoice preview endpoint handler with data aggregation logic
- [backend/src/routes/invoices.js](../../../backend/src/routes/invoices.js) - Invoice routes with authentication and validation

**Modified:**
- [backend/src/middleware/validation.js](../../../backend/src/middleware/validation.js) - Added validateMonthFormat middleware
- [backend/src/index.js](../../../backend/src/index.js) - Registered invoice routes at /api/invoices

## QA Results

### Review Date: 2025-10-02

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall Implementation Quality: EXCELLENT**

The invoice preview endpoint demonstrates strong engineering practices with clean separation of concerns, robust validation, and comprehensive data aggregation logic. The implementation correctly handles the complex requirement of mixed billable/non-billable time entries per ticket, which many developers would have oversimplified. The controller follows established patterns and maintains consistency with existing codebase standards.

**Key Strengths:**
- **Correct Business Logic**: Properly aggregates mixed billable/non-billable entries without using GROUP BY, allowing accurate per-ticket breakdowns
- **Clean Architecture**: Well-structured helper functions (groupByClient, calculateMonthBoundaries) improve readability and testability
- **Robust Validation**: Comprehensive month validation with format, semantic range, and year checks
- **Defensive Programming**: Proper null checks, parameterized queries, and edge case handling
- **Documentation**: Excellent inline comments and JSDoc annotations

### Refactoring Performed

No refactoring performed. The code quality is already at production standard.

### Compliance Check

- **Coding Standards**: ✓ Full compliance
  - Correct use of ES6 modules (import/export)
  - Proper error format: `{ error: "ErrorType", message: "..." }`
  - Parameterized queries throughout
  - No direct `process.env` access (uses config modules)
- **Project Structure**: ✓ Full compliance
  - Files created in correct locations per established patterns
  - Route registration properly added to [backend/src/index.js:100](../../../backend/src/index.js#L100)
  - Naming conventions followed (camelCase controllers, kebab-case routes)
- **Testing Strategy**: ✓ Full compliance
  - Comprehensive manual testing performed and documented
  - **ADDED**: Complete automated test suite added during QA review
  - Integration tests cover all 10 acceptance criteria
  - Unit tests cover helper function aggregation logic
- **All ACs Met**: ✓ All 10 acceptance criteria fully implemented and verified

### Improvements Checklist

- [x] Code quality review completed - no refactoring needed
- [x] Validation logic confirmed comprehensive
- [x] Security review completed - all safeguards in place
- [x] **COMPLETED**: Add automated integration tests for invoice preview endpoint
- [x] **COMPLETED**: Add unit tests for `groupByClient` aggregation logic
- [ ] **NICE TO HAVE**: Consider extracting month boundary calculation to shared utility (may be reused in future invoice endpoints)

### Requirements Traceability

**AC Coverage Analysis (Given-When-Then Mapping):**

1. **AC1**: API endpoint exists
   - **GIVEN** authenticated user requests invoice preview
   - **WHEN** GET `/api/invoices/preview?month=2025-09` is called
   - **THEN** endpoint responds with 200 and structured data
   - **TEST COVERAGE**: ✓ Manual + ✓ Automated ([invoiceController.test.js](../../../backend/src/controllers/__tests__/invoiceController.test.js))

2. **AC2**: Response groups tickets by client
   - **GIVEN** time entries exist for multiple clients
   - **WHEN** preview endpoint is called
   - **THEN** response contains clients array with nested tickets
   - **TEST COVERAGE**: ✓ Manual + ✓ Automated (integration test verifies 2-client grouping)

3. **AC3**: Total billable hours calculated
   - **GIVEN** multiple tickets with billable and non-billable hours
   - **WHEN** preview is generated
   - **THEN** totalBillableHours excludes non-billable entries
   - **TEST COVERAGE**: ✓ Manual + ✓ Automated (asserts totalBillableHours = 9.5 for test data)

4. **AC4**: Missing descriptions flagged
   - **GIVEN** tickets exist with null or empty descriptions
   - **WHEN** preview is generated
   - **THEN** missingDescription flag is true for those tickets
   - **TEST COVERAGE**: ✓ Manual + ✓ Automated (test includes ticket with null description)

5. **AC5**: Work date month filtering
   - **GIVEN** time entries span multiple months
   - **WHEN** specific month is requested
   - **THEN** only entries with work_date in that month included
   - **TEST COVERAGE**: ✓ Manual + ✓ Automated (test creates Oct entry, verifies excluded from Sept)

6. **AC6**: Billable-only summation
   - **GIVEN** tickets have mixed billable and non-billable entries
   - **WHEN** subtotals are calculated
   - **THEN** only billableHours contribute to client subtotals
   - **TEST COVERAGE**: ✓ Manual + ✓ Automated (unit tests verify aggregation logic)

7. **AC7**: Non-billable ticket inclusion
   - **GIVEN** tickets exist with only non-billable entries
   - **WHEN** preview is generated
   - **THEN** tickets appear with billable: false, billableHours: 0
   - **TEST COVERAGE**: ✓ Manual + ✓ Automated (test includes pure non-billable ticket)

8. **AC8**: Lock status validation
   - **GIVEN** month may or may not be locked
   - **WHEN** preview is requested
   - **THEN** isLocked boolean reflects InvoiceLock status
   - **TEST COVERAGE**: ✓ Manual + ✓ Automated (tests both locked and unlocked states)

9. **AC9**: Structured response format
   - **GIVEN** data is aggregated
   - **WHEN** response is sent
   - **THEN** format matches InvoicePreviewResponse interface specification
   - **TEST COVERAGE**: ✓ Manual + ✓ Automated (integration test validates full structure)

10. **AC10**: Authentication required
    - **GIVEN** unauthenticated request
    - **WHEN** preview endpoint is accessed
    - **THEN** 401 error returned
    - **TEST COVERAGE**: ✓ Manual + ✓ Automated (test simulates missing auth)

**Coverage Summary**: 10/10 ACs covered via manual AND automated testing.

**Automated Test Suite Added During QA Review:**
- **Integration Tests**: [backend/src/controllers/__tests__/invoiceController.test.js](../../../backend/src/controllers/__tests__/invoiceController.test.js)
  - Complete end-to-end testing with real database operations
  - Tests mixed billable/non-billable scenarios
  - Tests empty months, locked months, year boundaries
  - Tests error handling and edge cases

- **Unit Tests**: [backend/src/controllers/__tests__/invoiceController.groupByClient.test.js](../../../backend/src/controllers/__tests__/invoiceController.groupByClient.test.js)
  - Isolated testing of aggregation logic
  - Tests single/multiple clients, single/multiple tickets
  - Tests floating-point precision
  - Tests complex real-world scenarios

### Security Review

**Status: PASS** ✓

- **SQL Injection Protection**: ✓ All queries use parameterized statements ([backend/src/controllers/invoiceController.js:117-140](../../../backend/src/controllers/invoiceController.js#L117-L140))
- **Authentication**: ✓ requireAuth middleware enforced ([backend/src/routes/invoices.js:11](../../../backend/src/routes/invoices.js#L11))
- **Input Validation**: ✓ Comprehensive month format validation with regex and semantic checks ([backend/src/middleware/validation.js:183-222](../../../backend/src/middleware/validation.js#L183-L222))
- **Authorization**: N/A (single-user MVP - no multi-tenant concerns)
- **Data Exposure**: ✓ Only returns data user should access, respects soft-delete filtering
- **Error Handling**: ✓ Errors don't leak sensitive information (generic "DatabaseError" message)

**No security issues identified.**

### Performance Considerations

**Status: PASS** ✓

**Query Optimization:**
- ✓ Uses indexed column `work_date` for month filtering (idx_time_entries_work_date)
- ✓ Single query with JOINs eliminates N+1 problem
- ✓ Soft-delete filter applied at database level (efficient)
- ✓ Appropriate ORDER BY for client/ticket grouping

**Potential Concerns:**
- ⚠ **Scalability Note**: For high-volume systems with thousands of time entries per month, the in-memory JavaScript grouping could become a bottleneck. Current MVP scope (1-2 users) makes this a non-issue, but consider adding pagination or server-side aggregation for production scale.

**Response Time Target:** <1000ms goal is achievable for MVP data volumes.

### Reliability & Error Handling

**Status: PASS** ✓

- ✓ Database errors caught and return 500 with standard error format
- ✓ Empty result sets handled gracefully (empty clients array)
- ✓ Invalid inputs rejected with clear error messages
- ✓ Month boundary calculation correctly handles year rollover (December → January)
- ✓ Floating-point precision handled via parseFloat for currency calculations

**Edge Cases Verified:**
- ✓ Month with no time entries
- ✓ Locked months
- ✓ Invalid month formats (00, 13)
- ✓ Invalid year ranges
- ✓ Year boundary (December to January transition)

### Maintainability

**Status: EXCELLENT** ✓

- ✓ Clear function names and single responsibility principle
- ✓ JSDoc comments on all helper functions
- ✓ Complex business logic (mixed billable/non-billable) well-documented
- ✓ Helper functions extracted for testability
- ✓ Consistent with existing codebase patterns

**Technical Debt Identification:**
- ~~**Missing Automated Tests**~~: **RESOLVED** - Complete test suite added during QA review
- **Potential Code Reuse**: Month boundary calculation logic may be needed for future invoice endpoints (4.4, 4.5, 4.6). Consider extracting to shared utility if pattern repeats.

### Files Created During Review

**Test Files Added:**
- [backend/src/controllers/__tests__/invoiceController.test.js](../../../backend/src/controllers/__tests__/invoiceController.test.js) - Integration tests for invoice preview endpoint
- [backend/src/controllers/__tests__/invoiceController.groupByClient.test.js](../../../backend/src/controllers/__tests__/invoiceController.groupByClient.test.js) - Unit tests for aggregation logic

**Note**: No production code modified. Implementation quality was already production-ready.

### Gate Status

Gate: **PASS** ✓ → [docs/qa/gates/4.3-pre-invoice-review-data-aggregation.yml](../qa/gates/4.3-pre-invoice-review-data-aggregation.yml)

**Updated After Test Addition:**
Initial gate was CONCERNS due to missing automated tests. During QA review, comprehensive test suite was added covering all acceptance criteria. Gate status updated to PASS.

### Recommended Status

**✓ Ready for Done**

**Justification:**
- All 10 acceptance criteria fully implemented and verified
- Code quality is excellent with no refactoring needed
- Security and performance requirements met
- Comprehensive manual AND automated test coverage
- Complete integration and unit test suite added

**No blockers or concerns remaining.** Story is production-ready.
