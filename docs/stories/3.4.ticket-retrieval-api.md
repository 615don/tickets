# Story 3.4: Ticket Retrieval API Endpoints

## Status
**Draft**

## Story
**As a** developer,
**I want** API endpoints to retrieve tickets and their time entries,
**so that** the frontend can display ticket lists and details.

## Acceptance Criteria
1. `GET /api/tickets` returns all tickets with associated client/contact names and total hours (sum of time entries)
2. `GET /api/tickets?state=open` filters tickets by state (open/closed)
3. `GET /api/tickets?client_id=X` filters tickets by client
4. `GET /api/tickets/:id` returns single ticket with full details including all time entries
5. Time entries in response include work_date, duration_hours, billable flag
6. All endpoints require authentication
7. Endpoints return appropriate HTTP status codes (200, 404)
8. Results sorted by updated_at descending (most recent first)

## Tasks / Subtasks
- [ ] Task 1: Implement getAllTickets controller (AC: 1, 2, 3, 6, 7, 8)
  - [ ] Add `getAllTickets` function to `backend/src/controllers/ticketController.js`
  - [ ] Extract query parameters: `state`, `client_id` (clientId)
  - [ ] Call Ticket.findAll({ state, clientId }) with filters
  - [ ] Verify model returns tickets with client_name, contact_name, total_hours (computed)
  - [ ] Ensure results sorted by updated_at DESC (most recent first)
  - [ ] Return 200 status with tickets array
  - [ ] Wrap in try-catch with 500 error response
- [ ] Task 2: Implement getTicketById controller (AC: 4, 5, 6, 7)
  - [ ] Add `getTicketById` function to `backend/src/controllers/ticketController.js`
  - [ ] Extract ticket ID from req.params
  - [ ] Call Ticket.findById(id) to get ticket with client/contact details
  - [ ] Call TimeEntry.findByTicketId(id) to get all non-deleted time entries
  - [ ] Include time entries in response with work_date, duration_hours, billable
  - [ ] Return 404 if ticket not found
  - [ ] Return 200 status with ticket object including timeEntries array
  - [ ] Wrap in try-catch with 500 error response
- [ ] Task 3: Update Ticket model for list retrieval (AC: 1, 8)
  - [ ] Verify Ticket.findAll() in `backend/src/models/Ticket.js` supports filters
  - [ ] Add JOIN to clients table to include company_name as client_name
  - [ ] Add JOIN to contacts table to include name as contact_name
  - [ ] Add subquery or aggregate to compute total_hours (SUM of duration_hours from time_entries WHERE deleted_at IS NULL)
  - [ ] Support WHERE clause for state filter (state = ?)
  - [ ] Support WHERE clause for clientId filter (client_id = ?)
  - [ ] ORDER BY updated_at DESC
  - [ ] Return array of ticket objects with client_name, contact_name, total_hours
- [ ] Task 4: Update Ticket model for single ticket retrieval (AC: 4)
  - [ ] Verify Ticket.findById(id) in `backend/src/models/Ticket.js` includes JOINs
  - [ ] Add JOIN to clients table to include company_name as client_name
  - [ ] Add JOIN to contacts table to include name as contact_name
  - [ ] Return single ticket object or null if not found
- [ ] Task 5: Verify TimeEntry model for ticket time entries (AC: 5)
  - [ ] Verify TimeEntry.findByTicketId(ticketId) exists in `backend/src/models/TimeEntry.js`
  - [ ] Ensure query filters WHERE deleted_at IS NULL (exclude soft-deleted entries)
  - [ ] Return array with work_date, duration_hours, billable, id, created_at, updated_at
  - [ ] Order by work_date ASC (chronological order)
- [ ] Task 6: Add GET routes to ticket router (AC: 6)
  - [ ] Add GET / route in `backend/src/routes/tickets.js` with requireAuth middleware
  - [ ] Map to getAllTickets controller
  - [ ] Add GET /:id route with requireAuth middleware
  - [ ] Map to getTicketById controller
- [ ] Task 7: Test API endpoints (AC: all)
  - [ ] Test GET /api/tickets - returns all tickets with client/contact names and total hours
  - [ ] Test GET /api/tickets?state=open - filters to only open tickets
  - [ ] Test GET /api/tickets?state=closed - filters to only closed tickets
  - [ ] Test GET /api/tickets?client_id=1 - filters to only tickets for client 1
  - [ ] Test GET /api/tickets?state=open&client_id=1 - combined filters work
  - [ ] Test GET /api/tickets/:id with valid ID - returns ticket with time entries
  - [ ] Test GET /api/tickets/:id with invalid ID - returns 404
  - [ ] Verify total_hours calculation is correct (sum of non-deleted time entries)
  - [ ] Verify time entries exclude soft-deleted entries (deleted_at IS NULL)
  - [ ] Verify results sorted by updated_at DESC (newest first)
  - [ ] Test authentication requirement - 401 without session
  - [ ] Verify time entries sorted by work_date ASC

## Dev Notes

### Previous Story Context
[Source: Story 3.1 - Ticket Data Model]
- Ticket model created with `findAll()` and `findById()` methods
- TimeEntry model created with `findByTicketId()` method
- Models use Repository Pattern

[Source: Story 3.3 - Ticket Creation API]
- Ticket controller exists at `backend/src/controllers/ticketController.js`
- Ticket routes exist at `backend/src/routes/tickets.js`
- POST /api/tickets already implemented
- Pattern established for error handling and authentication

### Relevant Source Tree
[Source: docs/architecture/unified-project-structure.md]
- `backend/src/controllers/ticketController.js` - Add getAllTickets, getTicketById
- `backend/src/routes/tickets.js` - Add GET routes
- `backend/src/models/Ticket.js` - Update findAll() and findById() with JOINs
- `backend/src/models/TimeEntry.js` - Verify findByTicketId() implementation
- `backend/src/middleware/auth.js` - Existing authentication middleware

### API Specification
[Source: docs/architecture/api-specification.md#tickets]

**Endpoint**: `GET /api/tickets`

**Query Parameters**:
- `state` (optional): Filter by ticket state ("open" or "closed")
- `client_id` (optional): Filter by client ID (integer)

**Success Response** (200 OK):
```json
[
  {
    "id": 42,
    "clientId": 1,
    "clientName": "Acme Corp",
    "contactId": 5,
    "contactName": "John Doe",
    "description": "Fix login issue",
    "notes": "User reported via email",
    "state": "open",
    "closedAt": null,
    "totalHours": 3.5,
    "createdAt": "2025-10-01T14:30:00.000Z",
    "updatedAt": "2025-10-01T16:45:00.000Z"
  },
  {
    "id": 41,
    "clientId": 2,
    "clientName": "Beta LLC",
    "contactId": 8,
    "contactName": "Jane Smith",
    "description": "Server upgrade",
    "notes": null,
    "state": "closed",
    "closedAt": "2025-09-30T10:00:00.000Z",
    "totalHours": 8.0,
    "createdAt": "2025-09-29T09:00:00.000Z",
    "updatedAt": "2025-09-30T10:00:00.000Z"
  }
]
```

**Endpoint**: `GET /api/tickets/:id`

**URL Parameters**:
- `id` (required): Ticket ID (integer)

**Success Response** (200 OK):
```json
{
  "id": 42,
  "clientId": 1,
  "clientName": "Acme Corp",
  "contactId": 5,
  "contactName": "John Doe",
  "description": "Fix login issue",
  "notes": "User reported via email",
  "state": "open",
  "closedAt": null,
  "createdAt": "2025-10-01T14:30:00.000Z",
  "updatedAt": "2025-10-01T16:45:00.000Z",
  "timeEntries": [
    {
      "id": 100,
      "ticketId": 42,
      "workDate": "2025-10-01",
      "durationHours": 2.0,
      "billable": true,
      "createdAt": "2025-10-01T14:30:00.000Z",
      "updatedAt": "2025-10-01T14:30:00.000Z"
    },
    {
      "id": 101,
      "ticketId": 42,
      "workDate": "2025-10-02",
      "durationHours": 1.5,
      "billable": true,
      "createdAt": "2025-10-02T09:15:00.000Z",
      "updatedAt": "2025-10-02T09:15:00.000Z"
    }
  ]
}
```

**Error Response** (404 Not Found):
```json
{
  "error": "NotFound",
  "message": "Ticket with ID 999 not found"
}
```

### Controller Implementation Pattern

**getAllTickets Controller**:
```javascript
// GET /api/tickets - Get all tickets with optional filters
export const getAllTickets = async (req, res) => {
  try {
    const { state, client_id } = req.query;

    const filters = {};
    if (state) {
      filters.state = state;
    }
    if (client_id) {
      filters.clientId = parseInt(client_id, 10);
    }

    const tickets = await Ticket.findAll(filters);

    res.status(200).json(tickets);
  } catch (error) {
    console.error('Get tickets error:', error);
    res.status(500).json({
      error: 'InternalServerError',
      message: error.message
    });
  }
};
```

**getTicketById Controller**:
```javascript
// GET /api/tickets/:id - Get single ticket with time entries
export const getTicketById = async (req, res) => {
  try {
    const { id } = req.params;

    const ticket = await Ticket.findById(id);

    if (!ticket) {
      return res.status(404).json({
        error: 'NotFound',
        message: `Ticket with ID ${id} not found`
      });
    }

    // Get time entries for ticket
    const timeEntries = await TimeEntry.findByTicketId(id);

    // Include time entries in response
    const ticketWithEntries = {
      ...ticket,
      timeEntries
    };

    res.status(200).json(ticketWithEntries);
  } catch (error) {
    console.error('Get ticket error:', error);
    res.status(500).json({
      error: 'InternalServerError',
      message: error.message
    });
  }
};
```

### Model Implementation Guidance

**Ticket.findAll() with JOINs and Aggregation**:
[Source: Story 3.1 - Ticket Data Model]

```javascript
// backend/src/models/Ticket.js
export async function findAll({ state, clientId } = {}) {
  let query = `
    SELECT
      t.id,
      t.client_id,
      c.company_name AS client_name,
      t.contact_id,
      co.name AS contact_name,
      t.description,
      t.notes,
      t.state,
      t.closed_at,
      t.created_at,
      t.updated_at,
      COALESCE(SUM(te.duration_hours), 0) AS total_hours
    FROM tickets t
    LEFT JOIN clients c ON t.client_id = c.id
    LEFT JOIN contacts co ON t.contact_id = co.id
    LEFT JOIN time_entries te ON t.id = te.ticket_id AND te.deleted_at IS NULL
    WHERE 1=1
  `;

  const params = [];
  let paramIndex = 1;

  if (state) {
    query += ` AND t.state = $${paramIndex}`;
    params.push(state);
    paramIndex++;
  }

  if (clientId) {
    query += ` AND t.client_id = $${paramIndex}`;
    params.push(clientId);
    paramIndex++;
  }

  query += `
    GROUP BY t.id, c.company_name, co.name
    ORDER BY t.updated_at DESC
  `;

  const result = await pool.query(query, params);

  // Transform snake_case to camelCase
  return result.rows.map(row => ({
    id: row.id,
    clientId: row.client_id,
    clientName: row.client_name,
    contactId: row.contact_id,
    contactName: row.contact_name,
    description: row.description,
    notes: row.notes,
    state: row.state,
    closedAt: row.closed_at,
    totalHours: parseFloat(row.total_hours),
    createdAt: row.created_at,
    updatedAt: row.updated_at
  }));
}
```

**Ticket.findById() with JOINs**:
```javascript
// backend/src/models/Ticket.js
export async function findById(id) {
  const query = `
    SELECT
      t.id,
      t.client_id,
      c.company_name AS client_name,
      t.contact_id,
      co.name AS contact_name,
      t.description,
      t.notes,
      t.state,
      t.closed_at,
      t.created_at,
      t.updated_at
    FROM tickets t
    LEFT JOIN clients c ON t.client_id = c.id
    LEFT JOIN contacts co ON t.contact_id = co.id
    WHERE t.id = $1
  `;

  const result = await pool.query(query, [id]);

  if (result.rows.length === 0) {
    return null;
  }

  const row = result.rows[0];

  // Transform snake_case to camelCase
  return {
    id: row.id,
    clientId: row.client_id,
    clientName: row.client_name,
    contactId: row.contact_id,
    contactName: row.contact_name,
    description: row.description,
    notes: row.notes,
    state: row.state,
    closedAt: row.closed_at,
    createdAt: row.created_at,
    updatedAt: row.updated_at
  };
}
```

**TimeEntry.findByTicketId()**:
```javascript
// backend/src/models/TimeEntry.js
export async function findByTicketId(ticketId) {
  const query = `
    SELECT
      id,
      ticket_id,
      work_date,
      duration_hours,
      billable,
      created_at,
      updated_at
    FROM time_entries
    WHERE ticket_id = $1 AND deleted_at IS NULL
    ORDER BY work_date ASC
  `;

  const result = await pool.query(query, [ticketId]);

  // Transform snake_case to camelCase
  return result.rows.map(row => ({
    id: row.id,
    ticketId: row.ticket_id,
    workDate: row.work_date,
    durationHours: parseFloat(row.duration_hours),
    billable: row.billable,
    createdAt: row.created_at,
    updatedAt: row.updated_at
  }));
}
```

### Route Implementation

**Add GET Routes**:
[Source: backend/src/routes/tickets.js from Story 3.3]

```javascript
import express from 'express';
import { requireAuth } from '../middleware/auth.js';
import {
  createTicket,
  getAllTickets,
  getTicketById
} from '../controllers/ticketController.js';

const router = express.Router();

// All ticket routes require authentication
router.post('/', requireAuth, createTicket);
router.get('/', requireAuth, getAllTickets);
router.get('/:id', requireAuth, getTicketById);

export default router;
```

### Data Transformation Notes
[Source: docs/architecture/api-specification.md#data-transformation]

**Backend → Frontend**: snake_case → camelCase
- Database columns use snake_case: `client_id`, `contact_name`, `total_hours`
- API responses use camelCase: `clientId`, `contactName`, `totalHours`
- Transform in model layer (shown in implementation above)

### SQL Aggregation for Total Hours
[Source: Story 3.1 - TimeEntry data model]

**Calculate Total Hours**:
- Use `SUM(te.duration_hours)` from time_entries table
- Join with `LEFT JOIN` to handle tickets with no time entries
- Filter `WHERE te.deleted_at IS NULL` to exclude soft-deleted entries
- Use `COALESCE(SUM(...), 0)` to return 0 for tickets with no entries
- GROUP BY ticket fields to aggregate per ticket

### Testing

**Testing Strategy**: Manual testing for MVP
[Source: docs/architecture/testing-strategy.md]

**Manual Testing Checklist**:
- [ ] GET /api/tickets - returns array of all tickets
- [ ] Verify each ticket includes clientName, contactName, totalHours
- [ ] Verify totalHours is sum of non-deleted time entries
- [ ] Verify results sorted by updatedAt DESC (newest first)
- [ ] GET /api/tickets?state=open - returns only open tickets
- [ ] GET /api/tickets?state=closed - returns only closed tickets
- [ ] GET /api/tickets?client_id=1 - returns only tickets for client 1
- [ ] GET /api/tickets?state=open&client_id=1 - combined filters work
- [ ] GET /api/tickets/:id with valid ID - returns 200 with ticket object
- [ ] Verify ticket includes timeEntries array
- [ ] Verify timeEntries include workDate, durationHours, billable
- [ ] Verify timeEntries exclude soft-deleted entries
- [ ] Verify timeEntries sorted by workDate ASC
- [ ] GET /api/tickets/:id with invalid ID - returns 404
- [ ] Both endpoints without auth - return 401
- [ ] Create ticket with multiple time entries, verify totalHours sums correctly
- [ ] Soft delete time entry, verify totalHours updates and entry excluded

**Test with cURL**:
```bash
# Get all tickets
curl -X GET http://localhost:3001/api/tickets \
  -H "Cookie: connect.sid=<session_cookie>"

# Get open tickets
curl -X GET "http://localhost:3001/api/tickets?state=open" \
  -H "Cookie: connect.sid=<session_cookie>"

# Get tickets for client 1
curl -X GET "http://localhost:3001/api/tickets?client_id=1" \
  -H "Cookie: connect.sid=<session_cookie>"

# Get ticket by ID
curl -X GET http://localhost:3001/api/tickets/42 \
  -H "Cookie: connect.sid=<session_cookie>"
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-01 | 1.0 | Initial story draft created | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
(To be filled by Dev Agent)

### Debug Log References
(To be filled by Dev Agent)

### Completion Notes List
(To be filled by Dev Agent)

### File List
(To be filled by Dev Agent)

## QA Results
(To be filled by QA Agent)
